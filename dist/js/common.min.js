(function ($) {
    $.fn.countTo = function (options) {
        options = options || {};

        return $(this).each(function () {
            // set options for current element
            var settings = $.extend({}, $.fn.countTo.defaults, {
                from: $(this).data('from'),
                to: $(this).data('to'),
                speed: $(this).data('speed'),
                refreshInterval: $(this).data('refresh-interval'),
                decimals: $(this).data('decimals')
            }, options);

            // how many times to update the value, and how much to increment the value on each update
            var loops = Math.ceil(settings.speed / settings.refreshInterval),
                increment = (settings.to - settings.from) / loops;

            // references & variables that will change with each update
            var self = this,
                $self = $(this),
                loopCount = 0,
                value = settings.from,
                data = $self.data('countTo') || {};

            $self.data('countTo', data);

            // if an existing interval can be found, clear it first
            if (data.interval) {
                clearInterval(data.interval);
            }
            data.interval = setInterval(updateTimer, settings.refreshInterval);

            // initialize the element with the starting value
            render(value);

            function updateTimer() {
                value += increment;
                loopCount++;

                render(value);

                if (typeof(settings.onUpdate) == 'function') {
                    settings.onUpdate.call(self, value);
                }

                if (loopCount >= loops) {
                    // remove the interval
                    $self.removeData('countTo');
                    clearInterval(data.interval);
                    value = settings.to;

                    if (typeof(settings.onComplete) == 'function') {
                        settings.onComplete.call(self, value);
                    }
                }
            }

            function render(value) {
                var formattedValue = settings.formatter.call(self, value, settings);
                $self.html(formattedValue);
            }
        });
    };

    $.fn.countTo.defaults = {
        from: 0,               // the number the element should start at
        to: 0,                 // the number the element should end at
        speed: 1000,           // how long it should take to count between the target numbers
        refreshInterval: 100,  // how often the element should be updated
        decimals: 0,           // the number of decimal places to show
        formatter: formatter,  // handler for formatting the value before rendering
        onUpdate: null,        // callback method for every time the element is updated
        onComplete: null       // callback method for when the element finishes updating
    };

    function formatter(value, settings) {
        return value.toFixed(settings.decimals);
    }
}(jQuery));

jQuery(function ($) {
    // custom formatting example
    if ($('.data-info').is(':visible') == true) {
        $('.spincrement').data('countToOptions', {
            formatter: function (value, options) {
                return value.toFixed(options.decimals).replace(/\B(?=(?:\d{3})+(?!\d))/g, ' ');
            }
        });
        // start all the timers
        $('.spincrement').each(count);
    }

    function count(options) {
        var $this = $(this);
        options = $.extend({}, options || {}, $this.data('countToOptions') || {});
        $this.countTo(options);
    }
});
/* hover on filters in map section */
$('.map-info__filters').hover(function () {
    if ($('.map-info__type--title').is(':visible') == true) {
        $('.map-info__type--title').hide();
        $('.map-info__filters').removeClass('hover');
    }
    else {
        $(this).children('.map-info__type--title').show();
        $(this).addClass('hover');
    }
});

if ($(window).width() >= 992) {
    /* show description on news block */
    $('.description').hide();
    $('.small-news__info').hover(function () {
        $(this).children('.description').slideToggle();
    });
}

/* show all text on seo */
$(".seo-text__all-text").click(function () {
    var t = this;
    if ($(this).data("temp") || $(this).data("temp", $(this).text()),
    "" != $(this).data("link")) {
        var e = $('[data-id="' + $(this).data("link") + '"]');
        if (0 != e.length)
            if ($(this).hasClass("close"))
                $(this).css("opacity", 0),
                    e.removeClass("open"),
                    e.stop().animate({
                        "max-height": 140
                    }, 500, "linear", function () {
                        $(t).stop().animate({
                            opacity: 1
                        }, 500),
                            $(t).removeClass("close");
                        $('.seo-text__shadow').show();
                    }),
                    $(this).text($(this).data("temp"));
            else {
                $(this).css("opacity", 0),
                    e.addClass("open");
                var n = e.children().eq(0).outerHeight();
                e.stop().animate({
                    "max-height": n
                }, 500, "linear", function () {
                    $(t).stop().animate({
                        opacity: 1
                    }, 500),
                        $(t).addClass("close");
                    $('.seo-text__shadow').hide();
                }),
                    ($(this).text() === "Весь текст") ? $(this).text("Скрыть") : $(this).text("Весь текст");
            }
    }
}),

    /**/
    $('.menu-header').click(function () {
        $(this).children('.btn-nav').toggleClass("animated");
        $(this).parents('header').toggleClass('hover');
        $('.fixed-bg').toggle();
        // $('body').toggleClass('overflow');
    });

jQuery(document).ready(function (e) {
    e(".dropdown-toggle").click(function () {
        var t = e(this).parents(".button-dropdown").children(".dropdown-menu").is(":hidden");
        e(".button-dropdown .dropdown-menu").hide();
        e(".button-dropdown .dropdown-toggle").removeClass("active");
        if (t) {
            e(this).parents(".button-dropdown").children(".dropdown-menu").toggle().parents(".button-dropdown").children(".dropdown-toggle").addClass("active")
        }
    });
    e(document).bind("click", function (t) {
        var n = e(t.target);
        if (!n.parents().hasClass("button-dropdown")) e(".button-dropdown .dropdown-menu").hide();
    });
    e(document).bind("click", function (t) {
        var n = e(t.target);
        if (!n.parents().hasClass("button-dropdown")) e(".button-dropdown .dropdown-toggle").removeClass("active");
    })
});

/**/
$('.menu-header').click(function () {
    $(this).toggleClass('opened');
    $('.header-body').toggleClass('show');
});

/* tooltip on company page */
if ($(".selectpicker").length > 0) {
    $('.selectpicker').selectpicker();
}
if ($(".progress-bar").length > 0) {
    $(function () {
        $('[data-toggle="tooltip"]').tooltip({trigger: 'manual'}).tooltip('show');
    });
    /* progress bar on company page */
    $(window).scroll(function () {
        if ($(window).scrollTop() > 800) {
            $(".progress-bar").each(function () {
                each_bar_width = $(this).attr('aria-valuenow');
                $(this).width(each_bar_width + '%');
            });

        }
    });
}
$(function () {
    $(".expand").on("click", function () {
        $('.panel').removeClass('opened');
        $(this).parents('.panel').toggleClass('opened');
    });
});

/* click on print button */
$('.print').click(function () {
    window.print();
});

/* open full info about rent building */
if ($(".view-layouts").length > 0) {
    $('.view-layouts').click(function (event) {
        event.preventDefault();
        $('.special-list__body').removeClass('opened');
        $(this).parents('.special-list__body').toggleClass('opened');
    });
}

/* filter isotope */
if ($(".special-list").length > 0) {
// init Isotope
    var $grid = $('.special-list').isotope({
        // options
    });
// filter items on button click
    $('.news-list__filter--cover').on('click', 'a', function () {
        var filterValue = $(this).attr('data-filter');
        $grid.isotope({filter: filterValue});
    });

    /* ========= */


    var $grid_list = $('.special-list').isotope({
        itemSelector: '.special-list__body',
        masonry: {
            columnWidth: 100
        }
    });

    $grid_list.on('click', '.special-list__body', function () {
        // change size of item by toggling gigante class
        $(this).toggleClass('gigante');
        $grid_list.isotope('layout');
    });

}
if ($(".radio-input").length > 0) {
    $('.radio-input').click(function () {
        var input = $('.radio-input:checked');
        if (input) {
            $(this).next('.form-control').removeAttr('disabled');
            console.log('true');
        } else {
            console.log('false');
        }
    });
}

/* filter isotope */
if ($(".grid").length > 0) {
// init Isotope
    var $grid = $('.grid').isotope({
        itemSelector: '.element-item',
        layoutMode: 'fitRows'
    });

// bind filter button click
    $('.filters-button-group').on('click', 'button', function () {
        var filterValue = $(this).attr('data-filter');
        // use filterFn if matches value
        // filterValue = filterValue;
        $grid.isotope({filter: filterValue});
    });

// change is-checked class on buttons
    $('.button-group').each(function (i, buttonGroup) {
        var $buttonGroup = $(buttonGroup);
        $buttonGroup.on('click', 'button', function () {
            $buttonGroup.find('.is-checked').removeClass('is-checked');
            $(this).addClass('is-checked');
        });
    });
}

/* filter isotope end */
/* ImageMapster
   Version: 1.2.10 (2/25/2013)

Copyright 2011-2012 James Treworgy

http://www.outsharked.com/imagemapster
https://github.com/jamietre/ImageMapster

A jQuery plugin to enhance image maps.

*/

;

/// LICENSE (MIT License)
///
/// Permission is hereby granted, free of charge, to any person obtaining
/// a copy of this software and associated documentation files (the
/// "Software"), to deal in the Software without restriction, including
/// without limitation the rights to use, copy, modify, merge, publish,
/// distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to
/// the following conditions:
///
/// The above copyright notice and this permission notice shall be
/// included in all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
/// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
/// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
/// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///
/// January 19, 2011

/** @license MIT License (c) copyright B Cavalier & J Hann */

/**
* when
* A lightweight CommonJS Promises/A and when() implementation
*
* when is part of the cujo.js family of libraries (http://cujojs.com/)
*
* Licensed under the MIT License at:
* http://www.opensource.org/licenses/mit-license.php
*
* @version 1.2.0
*/

/*lint-ignore-start*/

(function (define) {
    define(function () {
        var freeze, reduceArray, slice, undef;

        //
        // Public API
        //

        when.defer = defer;
        when.reject = reject;
        when.isPromise = isPromise;

        when.all = all;
        when.some = some;
        when.any = any;

        when.map = map;
        when.reduce = reduce;

        when.chain = chain;

        /** Object.freeze */
        freeze = Object.freeze || function (o) { return o; };

        /**
        * Trusted Promise constructor.  A Promise created from this constructor is
        * a trusted when.js promise.  Any other duck-typed promise is considered
        * untrusted.
        *
        * @constructor
        */
        function Promise() { }

        Promise.prototype = freeze({
            always: function (alwaysback, progback) {
                return this.then(alwaysback, alwaysback, progback);
            },

            otherwise: function (errback) {
                return this.then(undef, errback);
            }
        });

        /**
        * Create an already-resolved promise for the supplied value
        * @private
        *
        * @param value anything
        * @return {Promise}
        */
        function resolved(value) {

            var p = new Promise();

            p.then = function (callback) {
                var nextValue;
                try {
                    if (callback) nextValue = callback(value);
                    return promise(nextValue === undef ? value : nextValue);
                } catch (e) {
                    return rejected(e);
                }
            };

            return freeze(p);
        }

        /**
        * Create an already-rejected {@link Promise} with the supplied
        * rejection reason.
        * @private
        *
        * @param reason rejection reason
        * @return {Promise}
        */
        function rejected(reason) {

            var p = new Promise();

            p.then = function (callback, errback) {
                var nextValue;
                try {
                    if (errback) {
                        nextValue = errback(reason);
                        return promise(nextValue === undef ? reason : nextValue)
                    }

                    return rejected(reason);

                } catch (e) {
                    return rejected(e);
                }
            };

            return freeze(p);
        }

        /**
        * Returns a rejected promise for the supplied promiseOrValue. If
        * promiseOrValue is a value, it will be the rejection value of the
        * returned promise.  If promiseOrValue is a promise, its
        * completion value will be the rejected value of the returned promise
        *
        * @param promiseOrValue {*} the rejected value of the returned {@link Promise}
        *
        * @return {Promise} rejected {@link Promise}
        */
        function reject(promiseOrValue) {
            return when(promiseOrValue, function (value) {
                return rejected(value);
            });
        }

        /**
        * Creates a new, CommonJS compliant, Deferred with fully isolated
        * resolver and promise parts, either or both of which may be given out
        * safely to consumers.
        * The Deferred itself has the full API: resolve, reject, progress, and
        * then. The resolver has resolve, reject, and progress.  The promise
        * only has then.
        *
        * @memberOf when
        * @function
        *
        * @returns {Deferred}
        */
        function defer() {
            var deferred, promise, listeners, progressHandlers, _then, _progress, complete;

            listeners = [];
            progressHandlers = [];

            /**
            * Pre-resolution then() that adds the supplied callback, errback, and progback
            * functions to the registered listeners
            *
            * @private
            *
            * @param [callback] {Function} resolution handler
            * @param [errback] {Function} rejection handler
            * @param [progback] {Function} progress handler
            *
            * @throws {Error} if any argument is not null, undefined, or a Function
            */
            _then = function unresolvedThen(callback, errback, progback) {
                var deferred = defer();

                listeners.push(function (promise) {
                    promise.then(callback, errback)
					.then(deferred.resolve, deferred.reject, deferred.progress);
                });

                progback && progressHandlers.push(progback);

                return deferred.promise;
            };

            /**
            * Registers a handler for this {@link Deferred}'s {@link Promise}.  Even though all arguments
            * are optional, each argument that *is* supplied must be null, undefined, or a Function.
            * Any other value will cause an Error to be thrown.
            *
            * @memberOf Promise
            *
            * @param [callback] {Function} resolution handler
            * @param [errback] {Function} rejection handler
            * @param [progback] {Function} progress handler
            *
            * @throws {Error} if any argument is not null, undefined, or a Function
            */
            function then(callback, errback, progback) {
                return _then(callback, errback, progback);
            }

            /**
            * Resolves this {@link Deferred}'s {@link Promise} with val as the
            * resolution value.
            *
            * @memberOf Resolver
            *
            * @param val anything
            */
            function resolve(val) {
                complete(resolved(val));
            }

            /**
            * Rejects this {@link Deferred}'s {@link Promise} with err as the
            * reason.
            *
            * @memberOf Resolver
            *
            * @param err anything
            */
            function reject(err) {
                complete(rejected(err));
            }

            /**
            * @private
            * @param update
            */
            _progress = function (update) {
                var progress, i = 0;
                while (progress = progressHandlers[i++]) progress(update);
            };

            /**
            * Emits a progress update to all progress observers registered with
            * this {@link Deferred}'s {@link Promise}
            *
            * @memberOf Resolver
            *
            * @param update anything
            */
            function progress(update) {
                _progress(update);
            }

            /**
            * Transition from pre-resolution state to post-resolution state, notifying
            * all listeners of the resolution or rejection
            *
            * @private
            *
            * @param completed {Promise} the completed value of this deferred
            */
            complete = function (completed) {
                var listener, i = 0;

                // Replace _then with one that directly notifies with the result.
                _then = completed.then;

                // Replace complete so that this Deferred can only be completed
                // once. Also Replace _progress, so that subsequent attempts to issue
                // progress throw.
                complete = _progress = function alreadyCompleted() {
                    // TODO: Consider silently returning here so that parties who
                    // have a reference to the resolver cannot tell that the promise
                    // has been resolved using try/catch
                    throw new Error("already completed");
                };

                // Free progressHandlers array since we'll never issue progress events
                // for this promise again now that it's completed
                progressHandlers = undef;

                // Notify listeners
                // Traverse all listeners registered directly with this Deferred

                while (listener = listeners[i++]) {
                    listener(completed);
                }

                listeners = [];
            };

            /**
            * The full Deferred object, with both {@link Promise} and {@link Resolver}
            * parts
            * @class Deferred
            * @name Deferred
            */
            deferred = {};

            // Promise and Resolver parts
            // Freeze Promise and Resolver APIs

            promise = new Promise();
            promise.then = deferred.then = then;

            /**
            * The {@link Promise} for this {@link Deferred}
            * @memberOf Deferred
            * @name promise
            * @type {Promise}
            */
            deferred.promise = freeze(promise);

            /**
            * The {@link Resolver} for this {@link Deferred}
            * @memberOf Deferred
            * @name resolver
            * @class Resolver
            */
            deferred.resolver = freeze({
                resolve: (deferred.resolve = resolve),
                reject: (deferred.reject = reject),
                progress: (deferred.progress = progress)
            });

            return deferred;
        }

        /**
        * Determines if promiseOrValue is a promise or not.  Uses the feature
        * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
        * promiseOrValue is a promise.
        *
        * @param promiseOrValue anything
        *
        * @returns {Boolean} true if promiseOrValue is a {@link Promise}
        */
        function isPromise(promiseOrValue) {
            return promiseOrValue && typeof promiseOrValue.then === 'function';
        }

        /**
        * Register an observer for a promise or immediate value.
        *
        * @function
        * @name when
        * @namespace
        *
        * @param promiseOrValue anything
        * @param {Function} [callback] callback to be called when promiseOrValue is
        *   successfully resolved.  If promiseOrValue is an immediate value, callback
        *   will be invoked immediately.
        * @param {Function} [errback] callback to be called when promiseOrValue is
        *   rejected.
        * @param {Function} [progressHandler] callback to be called when progress updates
        *   are issued for promiseOrValue.
        *
        * @returns {Promise} a new {@link Promise} that will complete with the return
        *   value of callback or errback or the completion value of promiseOrValue if
        *   callback and/or errback is not supplied.
        */
        function when(promiseOrValue, callback, errback, progressHandler) {
            // Get a promise for the input promiseOrValue
            // See promise()
            var trustedPromise = promise(promiseOrValue);

            // Register promise handlers
            return trustedPromise.then(callback, errback, progressHandler);
        }

        /**
        * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
        * promiseOrValue is a foreign promise, or a new, already-resolved {@link Promise}
        * whose resolution value is promiseOrValue if promiseOrValue is an immediate value.
        *
        * Note that this function is not safe to export since it will return its
        * input when promiseOrValue is a {@link Promise}
        *
        * @private
        *
        * @param promiseOrValue anything
        *
        * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
        *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
        *   whose resolution value is:
        *   * the resolution value of promiseOrValue if it's a foreign promise, or
        *   * promiseOrValue if it's a value
        */
        function promise(promiseOrValue) {
            var promise, deferred;

            if (promiseOrValue instanceof Promise) {
                // It's a when.js promise, so we trust it
                promise = promiseOrValue;

            } else {
                // It's not a when.js promise.  Check to see if it's a foreign promise
                // or a value.

                deferred = defer();
                if (isPromise(promiseOrValue)) {
                    // It's a compliant promise, but we don't know where it came from,
                    // so we don't trust its implementation entirely.  Introduce a trusted
                    // middleman when.js promise

                    // IMPORTANT: This is the only place when.js should ever call .then() on
                    // an untrusted promise.
                    promiseOrValue.then(deferred.resolve, deferred.reject, deferred.progress);
                    promise = deferred.promise;

                } else {
                    // It's a value, not a promise.  Create an already-resolved promise
                    // for it.
                    deferred.resolve(promiseOrValue);
                    promise = deferred.promise;
                }
            }

            return promise;
        }

        /**
        * Return a promise that will resolve when howMany of the supplied promisesOrValues
        * have resolved. The resolution value of the returned promise will be an array of
        * length howMany containing the resolutions values of the triggering promisesOrValues.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param howMany
        * @param [callback]
        * @param [errback]
        * @param [progressHandler]
        *
        * @returns {Promise}
        */
        function some(promisesOrValues, howMany, callback, errback, progressHandler) {

            checkCallbacks(2, arguments);

            return when(promisesOrValues, function (promisesOrValues) {

                var toResolve, results, ret, deferred, resolver, rejecter, handleProgress, len, i;

                len = promisesOrValues.length >>> 0;

                toResolve = Math.max(0, Math.min(howMany, len));
                results = [];
                deferred = defer();
                ret = when(deferred, callback, errback, progressHandler);

                // Wrapper so that resolver can be replaced
                function resolve(val) {
                    resolver(val);
                }

                // Wrapper so that rejecter can be replaced
                function reject(err) {
                    rejecter(err);
                }

                // Wrapper so that progress can be replaced
                function progress(update) {
                    handleProgress(update);
                }

                function complete() {
                    resolver = rejecter = handleProgress = noop;
                }

                // No items in the input, resolve immediately
                if (!toResolve) {
                    deferred.resolve(results);

                } else {
                    // Resolver for promises.  Captures the value and resolves
                    // the returned promise when toResolve reaches zero.
                    // Overwrites resolver var with a noop once promise has
                    // be resolved to cover case where n < promises.length
                    resolver = function (val) {
                        // This orders the values based on promise resolution order
                        // Another strategy would be to use the original position of
                        // the corresponding promise.
                        results.push(val);

                        if (! --toResolve) {
                            complete();
                            deferred.resolve(results);
                        }
                    };

                    // Rejecter for promises.  Rejects returned promise
                    // immediately, and overwrites rejecter var with a noop
                    // once promise to cover case where n < promises.length.
                    // TODO: Consider rejecting only when N (or promises.length - N?)
                    // promises have been rejected instead of only one?
                    rejecter = function (err) {
                        complete();
                        deferred.reject(err);
                    };

                    handleProgress = deferred.progress;

                    // TODO: Replace while with forEach
                    for (i = 0; i < len; ++i) {
                        if (i in promisesOrValues) {
                            when(promisesOrValues[i], resolve, reject, progress);
                        }
                    }
                }

                return ret;
            });
        }

        /**
        * Return a promise that will resolve only once all the supplied promisesOrValues
        * have resolved. The resolution value of the returned promise will be an array
        * containing the resolution values of each of the promisesOrValues.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param [callback] {Function}
        * @param [errback] {Function}
        * @param [progressHandler] {Function}
        *
        * @returns {Promise}
        */
        function all(promisesOrValues, callback, errback, progressHandler) {

            checkCallbacks(1, arguments);

            return when(promisesOrValues, function (promisesOrValues) {
                return _reduce(promisesOrValues, reduceIntoArray, []);
            }).then(callback, errback, progressHandler);
        }

        function reduceIntoArray(current, val, i) {
            current[i] = val;
            return current;
        }

        /**
        * Return a promise that will resolve when any one of the supplied promisesOrValues
        * has resolved. The resolution value of the returned promise will be the resolution
        * value of the triggering promiseOrValue.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param [callback] {Function}
        * @param [errback] {Function}
        * @param [progressHandler] {Function}
        *
        * @returns {Promise}
        */
        function any(promisesOrValues, callback, errback, progressHandler) {

            function unwrapSingleResult(val) {
                return callback ? callback(val[0]) : val[0];
            }

            return some(promisesOrValues, 1, unwrapSingleResult, errback, progressHandler);
        }

        /**
        * Traditional map function, similar to `Array.prototype.map()`, but allows
        * input to contain {@link Promise}s and/or values, and mapFunc may return
        * either a value or a {@link Promise}
        *
        * @memberOf when
        *
        * @param promise {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param mapFunc {Function} mapping function mapFunc(value) which may return
        *      either a {@link Promise} or value
        *
        * @returns {Promise} a {@link Promise} that will resolve to an array containing
        *      the mapped output values.
        */
        function map(promise, mapFunc) {
            return when(promise, function (array) {
                return _map(array, mapFunc);
            });
        }

        /**
        * Private map helper to map an array of promises
        * @private
        *
        * @param promisesOrValues {Array}
        * @param mapFunc {Function}
        * @return {Promise}
        */
        function _map(promisesOrValues, mapFunc) {

            var results, len, i;

            // Since we know the resulting length, we can preallocate the results
            // array to avoid array expansions.
            len = promisesOrValues.length >>> 0;
            results = new Array(len);

            // Since mapFunc may be async, get all invocations of it into flight
            // asap, and then use reduce() to collect all the results
            for (i = 0; i < len; i++) {
                if (i in promisesOrValues)
                    results[i] = when(promisesOrValues[i], mapFunc);
            }

            // Could use all() here, but that would result in another array
            // being allocated, i.e. map() would end up allocating 2 arrays
            // of size len instead of just 1.  Since all() uses reduce()
            // anyway, avoid the additional allocation by calling reduce
            // directly.
            return _reduce(results, reduceIntoArray, results);
        }

        /**
        * Traditional reduce function, similar to `Array.prototype.reduce()`, but
        * input may contain {@link Promise}s and/or values, and reduceFunc
        * may return either a value or a {@link Promise}, *and* initialValue may
        * be a {@link Promise} for the starting value.
        *
        * @memberOf when
        *
        * @param promise {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values.  May also be a {@link Promise} for
        *      an array.
        * @param reduceFunc {Function} reduce function reduce(currentValue, nextValue, index, total),
        *      where total is the total number of items being reduced, and will be the same
        *      in each call to reduceFunc.
        * @param initialValue starting value, or a {@link Promise} for the starting value
        *
        * @returns {Promise} that will resolve to the final reduced value
        */
        function reduce(promise, reduceFunc, initialValue) {
            var args = slice.call(arguments, 1);
            return when(promise, function (array) {
                return _reduce.apply(undef, [array].concat(args));
            });
        }

        /**
        * Private reduce to reduce an array of promises
        * @private
        *
        * @param promisesOrValues {Array}
        * @param reduceFunc {Function}
        * @param initialValue {*}
        * @return {Promise}
        */
        function _reduce(promisesOrValues, reduceFunc, initialValue) {

            var total, args;

            total = promisesOrValues.length;

            // Skip promisesOrValues, since it will be used as 'this' in the call
            // to the actual reduce engine below.

            // Wrap the supplied reduceFunc with one that handles promises and then
            // delegates to the supplied.

            args = [
			function (current, val, i) {
			    return when(current, function (c) {
			        return when(val, function (value) {
			            return reduceFunc(c, value, i, total);
			        });
			    });
			}
            ];

            if (arguments.length > 2) args.push(initialValue);

            return reduceArray.apply(promisesOrValues, args);
        }

        /**
        * Ensure that resolution of promiseOrValue will complete resolver with the completion
        * value of promiseOrValue, or instead with resolveValue if it is provided.
        *
        * @memberOf when
        *
        * @param promiseOrValue
        * @param resolver {Resolver}
        * @param [resolveValue] anything
        *
        * @returns {Promise}
        */
        function chain(promiseOrValue, resolver, resolveValue) {
            var useResolveValue = arguments.length > 2;

            return when(promiseOrValue,
			function (val) {
			    if (useResolveValue) val = resolveValue;
			    resolver.resolve(val);
			    return val;
			},
			function (e) {
			    resolver.reject(e);
			    return rejected(e);
			},
			resolver.progress
		);
        }

        //
        // Utility functions
        //

        /**
        * Helper that checks arrayOfCallbacks to ensure that each element is either
        * a function, or null or undefined.
        *
        * @private
        *
        * @param arrayOfCallbacks {Array} array to check
        * @throws {Error} if any element of arrayOfCallbacks is something other than
        * a Functions, null, or undefined.
        */
        function checkCallbacks(start, arrayOfCallbacks) {
            var arg, i = arrayOfCallbacks.length;
            while (i > start) {
                arg = arrayOfCallbacks[--i];
                if (arg != null && typeof arg != 'function') throw new Error('callback is not a function');
            }
        }

        /**
        * No-Op function used in method replacement
        * @private
        */
        function noop() { }

        slice = [].slice;

        // ES5 reduce implementation if native not available
        // See: http://es5.github.com/#x15.4.4.21 as there are many
        // specifics and edge cases.
        reduceArray = [].reduce ||
		function (reduceFunc /*, initialValue */) {
		    // ES5 dictates that reduce.length === 1

		    // This implementation deviates from ES5 spec in the following ways:
		    // 1. It does not check if reduceFunc is a Callable

		    var arr, args, reduced, len, i;

		    i = 0;
		    arr = Object(this);
		    len = arr.length >>> 0;
		    args = arguments;

		    // If no initialValue, use first item of array (we know length !== 0 here)
		    // and adjust i to start at second item
		    if (args.length <= 1) {
		        // Skip to the first real element in the array
		        for (; ;) {
		            if (i in arr) {
		                reduced = arr[i++];
		                break;
		            }

		            // If we reached the end of the array without finding any real
		            // elements, it's a TypeError
		            if (++i >= len) {
		                throw new TypeError();
		            }
		        }
		    } else {
		        // If initialValue provided, use it
		        reduced = args[1];
		    }

		    // Do the actual reduce
		    for (; i < len; ++i) {
		        // Skip holes
		        if (i in arr)
		            reduced = reduceFunc(reduced, arr[i], i, arr);
		    }

		    return reduced;
		};

        return when;
    });
})(typeof define == 'function'
	? define
	: function (factory) {
	    typeof module != 'undefined'
		? (module.exports = factory())
		: (jQuery.mapster_when = factory());
	}
// Boilerplate for AMD, Node, and browser global
);
/*lint-ignore-end*/
/* ImageMapster core */

/*jslint laxbreak: true, evil: true, unparam: true */

/*global jQuery: true, Zepto: true */


(function ($) {
    // all public functions in $.mapster.impl are methods
    $.fn.mapster = function (method) {
        var m = $.mapster.impl;
        if ($.isFunction(m[method])) {
            return m[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return m.bind.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.mapster');
        }
    };

    $.mapster = {
        version: "1.2.10",
        render_defaults: {
            isSelectable: true,
            isDeselectable: true,
            fade: false,
            fadeDuration: 150,
            fill: true,
            fillColor: '000000',
            fillColorMask: 'FFFFFF',
            fillOpacity: 0.7,
            highlight: true,
            stroke: false,
            strokeColor: 'ff0000',
            strokeOpacity: 1,
            strokeWidth: 1,
            includeKeys: '',
            altImage: null,
            altImageId: null, // used internally
            altImages: {}
        },
        defaults: {
            clickNavigate: false,
            wrapClass: null,
            wrapCss: null,
            onGetList: null,
            sortList: false,
            listenToList: false,
            mapKey: '',
            mapValue: '',
            singleSelect: false,
            listKey: 'value',
            listSelectedAttribute: 'selected',
            listSelectedClass: null,
            onClick: null,
            onMouseover: null,
            onMouseout: null,
            mouseoutDelay: 0,
            onStateChange: null,
            boundList: null,
            onConfigured: null,
            configTimeout: 30000,
            noHrefIsMask: true,
            scaleMap: true,
            safeLoad: false,
            areas: []
        },
        shared_defaults: {
            render_highlight: { fade: true },
            render_select: { fade: false },
            staticState: null,
            selected: null
        },
        area_defaults:
        {
            includeKeys: '',
            isMask: false
        },
        canvas_style: {
            position: 'absolute',
            left: 0,
            top: 0,
            padding: 0,
            border: 0
        },
        hasCanvas: null,
        isTouch: null,
        map_cache: [],
        hooks: {},
        addHook: function (name, callback) {
            this.hooks[name] = (this.hooks[name] || []).push(callback);
        },
        callHooks: function (name, context) {
            $.each(this.hooks[name] || [], function (i, e) {
                e.apply(context);
            });
        },
        utils: {
            when: $.mapster_when,
            defer: $.mapster_when.defer,

            // extends the constructor, returns a new object prototype. Does not refer to the
            // original constructor so is protected if the original object is altered. This way you
            // can "extend" an object by replacing it with its subclass.
            subclass: function (BaseClass, constr) {
                var Subclass = function () {
                    var me = this,
                        args = Array.prototype.slice.call(arguments, 0);
                    me.base = BaseClass.prototype;
                    me.base.init = function () {
                        BaseClass.prototype.constructor.apply(me, args);
                    };
                    constr.apply(me, args);
                };
                Subclass.prototype = new BaseClass();
                Subclass.prototype.constructor = Subclass;
                return Subclass;
            },
            asArray: function (obj) {
                return obj.constructor === Array ?
                    obj : this.split(obj);
            },
            // clean split: no padding or empty elements
            split: function (text, cb) {
                var i, el, arr = text.split(',');
                for (i = 0; i < arr.length; i++) {
                    el = $.trim(arr[i]);
                    if (el === '') {
                        arr.splice(i, 1);
                    } else {
                        arr[i] = cb ? cb(el) : el;
                    }
                }
                return arr;
            },
            // similar to $.extend but does not add properties (only updates), unless the
            // first argument is an empty object, then all properties will be copied
            updateProps: function (_target, _template) {
                var onlyProps,
                    target = _target || {},
                    template = $.isEmptyObject(target) ? _template : _target;

                //if (template) {
                onlyProps = [];
                $.each(template, function (prop) {
                    onlyProps.push(prop);
                });
                //}

                $.each(Array.prototype.slice.call(arguments, 1), function (i, src) {
                    $.each(src || {}, function (prop) {
                        if (!onlyProps || $.inArray(prop, onlyProps) >= 0) {
                            var p = src[prop];

                            if ($.isPlainObject(p)) {
                                // not recursive - only copies 1 level of subobjects, and always merges
                                target[prop] = $.extend(target[prop] || {}, p);
                            } else if (p && p.constructor === Array) {
                                target[prop] = p.slice(0);
                            } else if (typeof p !== 'undefined') {
                                target[prop] = src[prop];
                            }

                        }
                    });
                });
                return target;
            },
            isElement: function (o) {
                return (typeof HTMLElement === "object" ? o instanceof HTMLElement :
                        o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string");
            },
            // finds element of array or object with a property "prop" having value "val"
            // if prop is not defined, then just looks for property with value "val"
            indexOfProp: function (obj, prop, val) {
                var result = obj.constructor === Array ? -1 : null;
                $.each(obj, function (i, e) {
                    if (e && (prop ? e[prop] : e) === val) {
                        result = i;
                        return false;
                    }
                });
                return result;
            },
            // returns "obj" if true or false, or "def" if not true/false
            boolOrDefault: function (obj, def) {
                return this.isBool(obj) ?
                    obj : def || false;
            },
            isBool: function (obj) {
                return typeof obj === "boolean";
            },
            isUndef: function (obj) {
                return typeof obj === "undefined";
            },
            // evaluates "obj", if function, calls it with args
            // (todo - update this to handle variable lenght/more than one arg)
            ifFunction: function (obj, that, args) {
                if ($.isFunction(obj)) {
                    obj.call(that, args);
                }
            },
            size: function (image, raw) {
                var u = $.mapster.utils;
                return {
                    width: raw ? (image.width || image.naturalWidth) : u.imgWidth(image, true),
                    height: raw ? (image.height || image.naturalHeight) : u.imgHeight(image, true),
                    complete: function () { return !!this.height && !!this.width; }
                };
            },


            /**
             * Set the opacity of the element. This is an IE<8 specific function for handling VML.
             * When using VML we must override the "setOpacity" utility function (monkey patch ourselves).
             * jQuery does not deal with opacity correctly for VML elements. This deals with that.
             *
             * @param {Element} el The DOM element
             * @param {double} opacity A value between 0 and 1 inclusive.
             */

            setOpacity: function (el, opacity) {
                if ($.mapster.hasCanvas()) {
                    el.style.opacity = opacity;
                } else {
                    $(el).each(function (i, e) {
                        if (typeof e.opacity !== 'undefined') {
                            e.opacity = opacity;
                        } else {
                            $(e).css("opacity", opacity);
                        }
                    });
                }
            },


            // fade "el" from opacity "op" to "endOp" over a period of time "duration"

            fader: (function () {
                var elements = {},
                        lastKey = 0,
                        fade_func = function (el, op, endOp, duration) {
                            var index,
                                cbIntervals = duration / 15,
                                obj, u = $.mapster.utils;

                            if (typeof el === 'number') {
                                obj = elements[el];
                                if (!obj) {
                                    return;
                                }
                            } else {
                                index = u.indexOfProp(elements, null, el);
                                if (index) {
                                    delete elements[index];
                                }
                                elements[++lastKey] = obj = el;
                                el = lastKey;
                            }

                            endOp = endOp || 1;

                            op = (op + (endOp / cbIntervals) > endOp - 0.01) ? endOp : op + (endOp / cbIntervals);

                            u.setOpacity(obj, op);
                            if (op < endOp) {
                                setTimeout(function () {
                                    fade_func(el, op, endOp, duration);
                                }, 15);
                            }
                        };
                return fade_func;
            }())
        },
        getBoundList: function (opts, key_list) {
            if (!opts.boundList) {
                return null;
            }
            var index, key, result = $(), list = $.mapster.utils.split(key_list);
            opts.boundList.each(function (i, e) {
                for (index = 0; index < list.length; index++) {
                    key = list[index];
                    if ($(e).is('[' + opts.listKey + '="' + key + '"]')) {
                        result = result.add(e);
                    }
                }
            });
            return result;
        },
        // Causes changes to the bound list based on the user action (select or deselect)
        // area: the jQuery area object
        // returns the matching elements from the bound list for the first area passed (normally only one should be passed, but
        // a list can be passed
        setBoundListProperties: function (opts, target, selected) {
            target.each(function (i, e) {
                if (opts.listSelectedClass) {
                    if (selected) {
                        $(e).addClass(opts.listSelectedClass);
                    } else {
                        $(e).removeClass(opts.listSelectedClass);
                    }
                }
                if (opts.listSelectedAttribute) {
                    $(e).attr(opts.listSelectedAttribute, selected);
                }
            });
        },
        getMapDataIndex: function (obj) {
            var img, id;
            switch (obj.tagName && obj.tagName.toLowerCase()) {
                case 'area':
                    id = $(obj).parent().attr('name');
                    img = $("img[usemap='#" + id + "']")[0];
                    break;
                case 'img':
                    img = obj;
                    break;
            }
            return img ?
                this.utils.indexOfProp(this.map_cache, 'image', img) : -1;
        },
        getMapData: function (obj) {
            var index = this.getMapDataIndex(obj.length ? obj[0] : obj);
            if (index >= 0) {
                return index >= 0 ? this.map_cache[index] : null;
            }
        },
        /**
         * Queue a command to be run after the active async operation has finished
         * @param  {MapData}  map_data    The target MapData object
         * @param  {jQuery}   that        jQuery object on which the command was invoked
         * @param  {string}   command     the ImageMapster method name
         * @param  {object[]} args        arguments passed to the method
         * @return {bool}                 true if the command was queued, false if not (e.g. there was no need to)
         */
        queueCommand: function (map_data, that, command, args) {
            if (!map_data) {
                return false;
            }
            if (!map_data.complete || map_data.currentAction) {
                map_data.commands.push(
                {
                    that: that,
                    command: command,
                    args: args
                });
                return true;
            }
            return false;
        },
        unload: function () {
            this.impl.unload();
            this.utils = null;
            this.impl = null;
            $.fn.mapster = null;
            $.mapster = null;
            $('*').unbind();
        }
    };

    // Config for object prototypes
    // first: use only first object (for things that should not apply to lists)
    /// calls back one of two fuinctions, depending on whether an area was obtained.
    // opts: {
    //    name: 'method name',
    //    key: 'key,
    //    args: 'args'
    //
    //}
    // name: name of method (required)
    // args: arguments to re-call with
    // Iterates through all the objects passed, and determines whether it's an area or an image, and calls the appropriate
    // callback for each. If anything is returned from that callback, the process is stopped and that data return. Otherwise,
    // the object itself is returned.

    var m = $.mapster,
        u = m.utils,
        ap = Array.prototype;


    // jQuery's width() and height() are broken on IE9 in some situations. This tries everything.
    $.each(["width", "height"], function (i, e) {
        var capProp = e.substr(0, 1).toUpperCase() + e.substr(1);
        // when jqwidth parm is passed, it also checks the jQuery width()/height() property
        // the issue is that jQUery width() can report a valid size before the image is loaded in some browsers
        // without it, we can read zero even when image is loaded in other browsers if its not visible
        // we must still check because stuff like adblock can temporarily block it
        // what a goddamn headache
        u["img" + capProp] = function (img, jqwidth) {
            return (jqwidth ? $(img)[e]() : 0) ||
                img[e] || img["natural" + capProp] || img["client" + capProp] || img["offset" + capProp];
        };

    });

    /**
     * The Method object encapsulates the process of testing an ImageMapster method to see if it's being
     * invoked on an image, or an area; then queues the command if the MapData is in an active state.
     *
     * @param {[jQuery]}    that        The target of the invocation
     * @param {[function]}  func_map    The callback if the target is an imagemap
     * @param {[function]}  func_area   The callback if the target is an area
     * @param {[object]}    opt         Options: { key: a map key if passed explicitly
     *                                             name: the command name, if it can be queued,
     *                                             args: arguments to the method
     *                                            }
     */

    m.Method = function (that, func_map, func_area, opts) {
        var me = this;
        me.name = opts.name;
        me.output = that;
        me.input = that;
        me.first = opts.first || false;
        me.args = opts.args ? ap.slice.call(opts.args, 0) : [];
        me.key = opts.key;
        me.func_map = func_map;
        me.func_area = func_area;
        //$.extend(me, opts);
        me.name = opts.name;
        me.allowAsync = opts.allowAsync || false;
    };
    m.Method.prototype = {
        constructor: m.Method,
        go: function () {
            var i, data, ar, len, result, src = this.input,
                    area_list = [],
                    me = this;

            len = src.length;
            for (i = 0; i < len; i++) {
                data = $.mapster.getMapData(src[i]);
                if (data) {
                    if (!me.allowAsync && m.queueCommand(data, me.input, me.name, me.args)) {
                        if (this.first) {
                            result = '';
                        }
                        continue;
                    }

                    ar = data.getData(src[i].nodeName === 'AREA' ? src[i] : this.key);
                    if (ar) {
                        if ($.inArray(ar, area_list) < 0) {
                            area_list.push(ar);
                        }
                    } else {
                        result = this.func_map.apply(data, me.args);
                    }
                    if (this.first || typeof result !== 'undefined') {
                        break;
                    }
                }
            }
            // if there were areas, call the area function for each unique group
            $(area_list).each(function (i, e) {
                result = me.func_area.apply(e, me.args);
            });

            if (typeof result !== 'undefined') {
                return result;
            } else {
                return this.output;
            }
        }
    };

    $.mapster.impl = (function () {
        var me = {},
        addMap = function (map_data) {
            return m.map_cache.push(map_data) - 1;
        },
        removeMap = function (map_data) {
            m.map_cache.splice(map_data.index, 1);
            for (var i = m.map_cache.length - 1; i >= this.index; i--) {
                m.map_cache[i].index--;
            }
        };


        /**
         * Test whether the browser supports VML. Credit: google.
         * http://stackoverflow.com/questions/654112/how-do-you-detect-support-for-vml-or-svg-in-a-browser
         *
         * @return {bool} true if vml is supported, false if not
         */

        function hasVml() {
            var a = $('<div />').appendTo('body');
            a.html('<v:shape id="vml_flag1" adj="1" />');

            var b = a[0].firstChild;
            b.style.behavior = "url(#default#VML)";
            var has = b ? typeof b.adj === "object" : true;
            a.remove();
            return has;
        }

        /**
         * Return a reference to the IE namespaces object, if available, or an empty object otherwise
         * @return {obkect} The document.namespaces object.
         */
        function namespaces() {
            return typeof (document.namespaces) === 'object' ?
                document.namespaces :
                null;
        }

        /**
         * Test for the presence of HTML5 Canvas support. This also checks to see if excanvas.js has been
         * loaded and is faking it; if so, we assume that canvas is not supported.
         *
         * @return {bool} true if HTML5 canvas support, false if not
         */

        function hasCanvas() {
            var d = namespaces();
            // when g_vml_ is present, then we can be sure excanvas is active, meaning there's not a real canvas.

            return d && d.g_vml_ ?
               false :
               $('<canvas />')[0].getContext ?
                   true :
                   false;
        }

        /**
         * Merge new area data into existing area options on a MapData object. Used for rebinding.
         *
         * @param  {[MapData]} map_data     The MapData object
         * @param  {[object[]]} areas       areas array to merge
         */

        function merge_areas(map_data, areas) {
            var ar, index,
                map_areas = map_data.options.areas;

            if (areas) {
                $.each(areas, function (i, e) {

                    // Issue #68 - ignore invalid data in areas array

                    if (!e || !e.key) {
                        return;
                    }

                    index = u.indexOfProp(map_areas, "key", e.key);

                    if (index >= 0) {
                        $.extend(map_areas[index], e);
                    }
                    else {
                        map_areas.push(e);
                    }
                    ar = map_data.getDataForKey(e.key);
                    if (ar) {
                        $.extend(ar.options, e);
                    }
                });
            }
        }
        function merge_options(map_data, options) {
            var temp_opts = u.updateProps({}, options);
            delete temp_opts.areas;

            u.updateProps(map_data.options, temp_opts);

            merge_areas(map_data, options.areas);
            // refresh the area_option template
            u.updateProps(map_data.area_options, map_data.options);
        }

        // Most methods use the "Method" object which handles figuring out whether it's an image or area called and
        // parsing key parameters. The constructor wants:
        // this, the jQuery object
        // a function that is called when an image was passed (with a this context of the MapData)
        // a function that is called when an area was passed (with a this context of the AreaData)
        // options: first = true means only the first member of a jQuery object is handled
        //          key = the key parameters passed
        //          defaultReturn: a value to return other than the jQuery object (if its not chainable)
        //          args: the arguments
        // Returns a comma-separated list of user-selected areas. "staticState" areas are not considered selected for the purposes of this method.

        me.get = function (key) {
            var md = m.getMapData(this);
            if (!(md && md.complete)) {
                throw ("Can't access data until binding complete.");
            }

            return (new m.Method(this,
                function () {
                    // map_data return
                    return this.getSelected();
                },
                function () {
                    return this.isSelected();
                },
                {
                    name: 'get',
                    args: arguments,
                    key: key,
                    first: true,
                    allowAsync: true,
                    defaultReturn: ''
                }
            )).go();
        };
        me.data = function (key) {
            return (new m.Method(this,
                null,
                function () {
                    return this;
                },
                {
                    name: 'data',
                    args: arguments,
                    key: key
                }
            )).go();
        };


        // Set or return highlight state.
        //  $(img).mapster('highlight') -- return highlighted area key, or null if none
        //  $(area).mapster('highlight') -- highlight an area
        //  $(img).mapster('highlight','area_key') -- highlight an area
        //  $(img).mapster('highlight',false) -- remove highlight
        me.highlight = function (key) {
            return (new m.Method(this,
                function () {
                    if (key === false) {
                        this.ensureNoHighlight();
                    } else {
                        var id = this.highlightId;
                        return id >= 0 ? this.data[id].key : null;
                    }
                },
                function () {
                    this.highlight();
                },
                {
                    name: 'highlight',
                    args: arguments,
                    key: key,
                    first: true
                }
            )).go();
        };
        // Return the primary keys for an area or group key.
        // $(area).mapster('key')
        // includes all keys (not just primary keys)
        // $(area).mapster('key',true)
        // $(img).mapster('key','group-key')

        // $(img).mapster('key','group-key', true)
        me.keys = function (key, all) {
            var keyList = [],
                md = m.getMapData(this);

            if (!(md && md.complete)) {
                throw ("Can't access data until binding complete.");
            }


            function addUniqueKeys(ad) {
                var areas, keys = [];
                if (!all) {
                    keys.push(ad.key);
                } else {
                    areas = ad.areas();
                    $.each(areas, function (i, e) {
                        keys = keys.concat(e.keys);
                    });
                }
                $.each(keys, function (i, e) {
                    if ($.inArray(e, keyList) < 0) {
                        keyList.push(e);
                    }
                });
            }

            if (!(md && md.complete)) {
                return '';
            }
            if (typeof key === 'string') {
                if (all) {
                    addUniqueKeys(md.getDataForKey(key));
                } else {
                    keyList = [md.getKeysForGroup(key)];
                }
            } else {
                all = key;
                this.each(function (i, e) {
                    if (e.nodeName === 'AREA') {
                        addUniqueKeys(md.getDataForArea(e));
                    }
                });
            }
            return keyList.join(',');


        };
        me.select = function () {
            me.set.call(this, true);
        };
        me.deselect = function () {
            me.set.call(this, false);
        };

        /**
         * Select or unselect areas. Areas can be identified by a single string key, a comma-separated list of keys,
         * or an array of strings.
         *
         *
         * @param {boolean} selected Determines whether areas are selected or deselected
         * @param {string|string[]} key A string, comma-separated string, or array of strings indicating
         *                              the areas to select or deselect
         * @param {object} options Rendering options to apply when selecting an area
         */

        me.set = function (selected, key, options) {
            var lastMap, map_data, opts = options,
                key_list, area_list; // array of unique areas passed

            function setSelection(ar) {
                if (ar) {
                    switch (selected) {
                        case true:
                            ar.select(opts); break;
                        case false:
                            ar.deselect(true); break;
                        default:
                            ar.toggle(opts); break;
                    }
                }
            }
            function addArea(ar) {
                if (ar && $.inArray(ar, area_list) < 0) {
                    area_list.push(ar);
                    key_list += (key_list === '' ? '' : ',') + ar.key;
                }
            }
            // Clean up after a group that applied to the same map
            function finishSetForMap(map_data) {
                $.each(area_list, function (i, el) {
                    setSelection(el);
                });
                if (!selected) {
                    map_data.removeSelectionFinish();
                }
                if (map_data.options.boundList) {
                    m.setBoundListProperties(map_data.options, m.getBoundList(map_data.options, key_list), selected);
                }
            }

            this.filter('img,area').each(function (i, e) {
                var keys;
                map_data = m.getMapData(e);

                if (map_data !== lastMap) {
                    if (lastMap) {
                        finishSetForMap(lastMap);
                    }

                    area_list = [];
                    key_list = '';
                }

                if (map_data) {

                    keys = '';
                    if (e.nodeName.toUpperCase() === 'IMG') {
                        if (!m.queueCommand(map_data, $(e), 'set', [selected, key, opts])) {
                            if (key instanceof Array) {
                                if (key.length) {
                                    keys = key.join(",");
                                }
                            }
                            else {
                                keys = key;
                            }

                            if (keys) {
                                $.each(u.split(keys), function (i, key) {
                                    addArea(map_data.getDataForKey(key.toString()));
                                    lastMap = map_data;
                                });
                            }
                        }
                    } else {
                        opts = key;
                        if (!m.queueCommand(map_data, $(e), 'set', [selected, opts])) {
                            addArea(map_data.getDataForArea(e));
                            lastMap = map_data;
                        }

                    }
                }
            });

            if (map_data) {
                finishSetForMap(map_data);
            }


            return this;
        };
        me.unbind = function (preserveState) {
            return (new m.Method(this,
                function () {
                    this.clearEvents();
                    this.clearMapData(preserveState);
                    removeMap(this);
                },
                null,
                {
                    name: 'unbind',
                    args: arguments
                }
            )).go();
        };


        // refresh options and update selection information.
        me.rebind = function (options) {
            return (new m.Method(this,
                function () {
                    var me = this;

                    me.complete = false;
                    me.configureOptions(options);
                    me.bindImages().then(function () {
                        me.buildDataset(true);
                        me.complete = true;
                    });
                    //this.redrawSelections();
                },
                null,
                {
                    name: 'rebind',
                    args: arguments
                }
            )).go();
        };
        // get options. nothing or false to get, or "true" to get effective options (versus passed options)
        me.get_options = function (key, effective) {
            var eff = u.isBool(key) ? key : effective; // allow 2nd parm as "effective" when no key
            return (new m.Method(this,
                function () {
                    var opts = $.extend({}, this.options);
                    if (eff) {
                        opts.render_select = u.updateProps(
                            {},
                            m.render_defaults,
                            opts,
                            opts.render_select);

                        opts.render_highlight = u.updateProps(
                            {},
                            m.render_defaults,
                            opts,
                            opts.render_highlight);
                    }
                    return opts;
                },
                function () {
                    return eff ? this.effectiveOptions() : this.options;
                },
                {
                    name: 'get_options',
                    args: arguments,
                    first: true,
                    allowAsync: true,
                    key: key
                }
            )).go();
        };

        // set options - pass an object with options to set,
        me.set_options = function (options) {
            return (new m.Method(this,
                function () {
                    merge_options(this, options);
                },
                null,
                {
                    name: 'set_options',
                    args: arguments
                }
            )).go();
        };
        me.unload = function () {
            var i;
            for (i = m.map_cache.length - 1; i >= 0; i--) {
                if (m.map_cache[i]) {
                    me.unbind.call($(m.map_cache[i].image));
                }
            }
            me.graphics = null;
        };

        me.snapshot = function () {
            return (new m.Method(this,
                function () {
                    $.each(this.data, function (i, e) {
                        e.selected = false;
                    });

                    this.base_canvas = this.graphics.createVisibleCanvas(this);
                    $(this.image).before(this.base_canvas);
                },
                null,
                { name: 'snapshot' }
            )).go();
        };

        // do not queue this function

        me.state = function () {
            var md, result = null;
            $(this).each(function (i, e) {
                if (e.nodeName === 'IMG') {
                    md = m.getMapData(e);
                    if (md) {
                        result = md.state();
                    }
                    return false;
                }
            });
            return result;
        };

        me.bind = function (options) {

            return this.each(function (i, e) {
                var img, map, usemap, md;

                // save ref to this image even if we can't access it yet. commands will be queued
                img = $(e);

                md = m.getMapData(e);

                // if already bound completely, do a total rebind

                if (md) {
                    me.unbind.apply(img);
                    if (!md.complete) {
                        // will be queued
                        img.bind();
                        return true;
                    }
                    md = null;
                }

                // ensure it's a valid image
                // jQuery bug with Opera, results in full-url#usemap being returned from jQuery's attr.
                // So use raw getAttribute instead.

                usemap = this.getAttribute('usemap');
                map = usemap && $('map[name="' + usemap.substr(1) + '"]');
                if (!(img.is('img') && usemap && map.size() > 0)) {
                    return true;
                }

                // sorry - your image must have border:0, things are too unpredictable otherwise.
                img.css('border', 0);

                if (!md) {
                    md = new m.MapData(this, options);

                    md.index = addMap(md);
                    md.map = map;
                    md.bindImages().then(function () {
                        md.initialize();
                    });
                }
            });
        };

        me.init = function (useCanvas) {
            var style, shapes;

            // for testing/debugging, use of canvas can be forced by initializing
            // manually with "true" or "false". But generally we test for it.

            m.hasCanvas = function () {
                if (!u.isBool(m.hasCanvas.value)) {
                    m.hasCanvas.value = u.isBool(useCanvas) ?
                        useCanvas :
                        hasCanvas();
                }
                return m.hasCanvas.value;
            };
            m.hasVml = function () {
                if (!u.isBool(m.hasVml.value)) {
                    // initialize VML the first time we detect its presence.
                    var d = namespaces();

                    if (d && !d.v) {
                        d.add("v", "urn:schemas-microsoft-com:vml");
                        style = document.createStyleSheet();
                        shapes = ['shape', 'rect', 'oval', 'circ', 'fill', 'stroke', 'imagedata', 'group', 'textbox'];
                        $.each(shapes,
                        function (i, el) {
                            style.addRule('v\\:' + el, "behavior: url(#default#VML); antialias:true");
                        });
                    }
                    m.hasVml.value = hasVml();
                }

                return m.hasVml.value;
            };

            m.isTouch = !!document.documentElement.ontouchstart;

            $.extend(m.defaults, m.render_defaults, m.shared_defaults);
            $.extend(m.area_defaults, m.render_defaults, m.shared_defaults);

        };
        me.test = function (obj) {
            return eval(obj);
        };
        return me;
    }());

    $.mapster.impl.init();


}(jQuery));
/* graphics.js
   Graphics object handles all rendering.
*/
(function ($) {
    var p, m = $.mapster,
        u = m.utils,
        canvasMethods,
        vmlMethods;

    /**
     * Implemenation to add each area in an AreaData object to the canvas
     * @param {Graphics} graphics The target graphics object
     * @param {AreaData} areaData The AreaData object (a collection of area elements and metadata)
     * @param {object} options Rendering options to apply when rendering this group of areas
     */
    function addShapeGroupImpl(graphics, areaData, options) {
        var me = graphics,
            md = me.map_data,
            isMask = options.isMask;

        // first get area options. Then override fade for selecting, and finally merge in the
        // "select" effect options.

        $.each(areaData.areas(), function (i, e) {
            options.isMask = isMask || (e.nohref && md.options.noHrefIsMask);
            me.addShape(e, options);
        });

        // it's faster just to manipulate the passed options isMask property and restore it, than to
        // copy the object each time

        options.isMask = isMask;

    }

    /**
    * Convert a hex value to decimal
    * @param  {string} hex A hexadecimal toString
    * @return {int} Integer represenation of the hex string
    */

    function hex_to_decimal(hex) {
        return Math.max(0, Math.min(parseInt(hex, 16), 255));
    }
    function css3color(color, opacity) {
        return 'rgba(' + hex_to_decimal(color.substr(0, 2)) + ','
                + hex_to_decimal(color.substr(2, 2)) + ','
                + hex_to_decimal(color.substr(4, 2)) + ',' + opacity + ')';
    }
    /**
     * An object associated with a particular map_data instance to manage renderin.
     * @param {MapData} map_data The MapData object bound to this instance
     */

    m.Graphics = function (map_data) {
        //$(window).unload($.mapster.unload);
        // create graphics functions for canvas and vml browsers. usage:
        // 1) init with map_data, 2) call begin with canvas to be used (these are separate b/c may not require canvas to be specified
        // 3) call add_shape_to for each shape or mask, 4) call render() to finish

        var me = this;
        me.active = false;
        me.canvas = null;
        me.width = 0;
        me.height = 0;
        me.shapes = [];
        me.masks = [];
        me.map_data = map_data;
    };

    p = m.Graphics.prototype = {
        constructor: m.Graphics,

        /**
         * Initiate a graphics request for a canvas
         * @param  {Element} canvas The canvas element that is the target of this operation
         * @param  {string} [elementName] The name to assign to the element (VML only)
         */

        begin: function (canvas, elementName) {
            var c = $(canvas);

            this.elementName = elementName;
            this.canvas = canvas;

            this.width = c.width();
            this.height = c.height();
            this.shapes = [];
            this.masks = [];
            this.active = true;

        },

        /**
         * Add an area to be rendered to this canvas.
         * @param {MapArea} mapArea The MapArea object to render
         * @param {object} options An object containing any rendering options that should override the
         *                         defaults for the area
         */

        addShape: function (mapArea, options) {
            var addto = options.isMask ? this.masks : this.shapes;
            addto.push({ mapArea: mapArea, options: options });
        },

        /**
         * Create a canvas that is sized and styled for the MapData object
         * @param  {MapData} mapData The MapData object that will receive this new canvas
         * @return {Element} A canvas element
         */

        createVisibleCanvas: function (mapData) {
            return $(this.createCanvasFor(mapData))
                .addClass('mapster_el')
                .css(m.canvas_style)[0];
        },

        /**
         * Add a group of shapes from an AreaData object to the canvas
         *
         * @param {AreaData} areaData An AreaData object (a set of area elements)
         * @param {string} mode     The rendering mode, "select" or "highlight". This determines the target
         *                          canvas and which default options to use.
         * @param {striong} options  Rendering options
         */

        addShapeGroup: function (areaData, mode, options) {
            // render includeKeys first - because they could be masks
            var me = this,
                list, name, canvas,
                map_data = this.map_data,
                opts = areaData.effectiveRenderOptions(mode);

            if (options) {
                $.extend(opts, options);
            }

            if (mode === 'select') {
                name = "static_" + areaData.areaId.toString();
                canvas = map_data.base_canvas;
            } else {
                canvas = map_data.overlay_canvas;
            }

            me.begin(canvas, name);

            if (opts.includeKeys) {
                list = u.split(opts.includeKeys);
                $.each(list, function (i, e) {
                    var areaData = map_data.getDataForKey(e.toString());
                    addShapeGroupImpl(me, areaData, areaData.effectiveRenderOptions(mode));
                });
            }

            addShapeGroupImpl(me, areaData, opts);
            me.render();
            if (opts.fade) {

                // fading requires special handling for IE. We must access the fill elements directly. The fader also has to deal with
                // the "opacity" attribute (not css)

                u.fader(m.hasCanvas() ?
                    canvas :
                    $(canvas).find('._fill').not('.mapster_mask'),
                0,
                m.hasCanvas() ?
                    1 :
                    opts.fillOpacity,
                opts.fadeDuration);

            }

        }

        // These prototype methods are implementation dependent
    };

    function noop() { }


    // configure remaining prototype methods for ie or canvas-supporting browser

    canvasMethods = {
        renderShape: function (context, mapArea, offset) {
            var i,
                c = mapArea.coords(null, offset);

            switch (mapArea.shape) {
                case 'rect':
                    context.rect(c[0], c[1], c[2] - c[0], c[3] - c[1]);
                    break;
                case 'poly':
                    context.moveTo(c[0], c[1]);

                    for (i = 2; i < mapArea.length; i += 2) {
                        context.lineTo(c[i], c[i + 1]);
                    }
                    context.lineTo(c[0], c[1]);
                    break;
                case 'circ':
                case 'circle':
                    context.arc(c[0], c[1], c[2], 0, Math.PI * 2, false);
                    break;
            }
        },
        addAltImage: function (context, image, mapArea, options) {
            context.beginPath();

            this.renderShape(context, mapArea);
            context.closePath();
            context.clip();

            context.globalAlpha = options.altImageOpacity || options.fillOpacity;

            context.drawImage(image, 0, 0, mapArea.owner.scaleInfo.width, mapArea.owner.scaleInfo.height);
        },
        render: function () {
            // firefox 6.0 context.save() seems to be broken. to work around,  we have to draw the contents on one temp canvas,
            // the mask on another, and merge everything. ugh. fixed in 1.2.2. unfortunately this is a lot more code for masks,
            // but no other way around it that i can see.

            var maskCanvas, maskContext,
                        me = this,
                        md = me.map_data,
                        hasMasks = me.masks.length,
                        shapeCanvas = me.createCanvasFor(md),
                        shapeContext = shapeCanvas.getContext('2d'),
                        context = me.canvas.getContext('2d');

            if (hasMasks) {
                maskCanvas = me.createCanvasFor(md);
                maskContext = maskCanvas.getContext('2d');
                maskContext.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

                $.each(me.masks, function (i, e) {
                    maskContext.save();
                    maskContext.beginPath();
                    me.renderShape(maskContext, e.mapArea);
                    maskContext.closePath();
                    maskContext.clip();
                    maskContext.lineWidth = 0;
                    maskContext.fillStyle = '#000';
                    maskContext.fill();
                    maskContext.restore();
                });

            }

            $.each(me.shapes, function (i, s) {
                shapeContext.save();
                if (s.options.fill) {
                    if (s.options.altImageId) {
                        me.addAltImage(shapeContext, md.images[s.options.altImageId], s.mapArea, s.options);
                    } else {
                        shapeContext.beginPath();
                        me.renderShape(shapeContext, s.mapArea);
                        shapeContext.closePath();
                        //shapeContext.clip();
                        shapeContext.fillStyle = css3color(s.options.fillColor, s.options.fillOpacity);
                        shapeContext.fill();
                    }
                }
                shapeContext.restore();
            });


            // render strokes at end since masks get stroked too

            $.each(me.shapes.concat(me.masks), function (i, s) {
                var offset = s.options.strokeWidth === 1 ? 0.5 : 0;
                // offset applies only when stroke width is 1 and stroke would render between pixels.

                if (s.options.stroke) {
                    shapeContext.save();
                    shapeContext.strokeStyle = css3color(s.options.strokeColor, s.options.strokeOpacity);
                    shapeContext.lineWidth = s.options.strokeWidth;

                    shapeContext.beginPath();

                    me.renderShape(shapeContext, s.mapArea, offset);
                    shapeContext.closePath();
                    shapeContext.stroke();
                    shapeContext.restore();
                }
            });

            if (hasMasks) {
                // render the new shapes against the mask

                maskContext.globalCompositeOperation = "source-out";
                maskContext.drawImage(shapeCanvas, 0, 0);

                // flatten into the main canvas
                context.drawImage(maskCanvas, 0, 0);
            } else {
                context.drawImage(shapeCanvas, 0, 0);
            }

            me.active = false;
            return me.canvas;
        },

        // create a canvas mimicing dimensions of an existing element
        createCanvasFor: function (md) {
            return $('<canvas width="' + md.scaleInfo.width + '" height="' + md.scaleInfo.height + '"></canvas>')[0];
        },
        clearHighlight: function () {
            var c = this.map_data.overlay_canvas;
            c.getContext('2d').clearRect(0, 0, c.width, c.height);
        },
        // Draw all items from selected_list to a new canvas, then swap with the old one. This is used to delete items when using canvases.
        refreshSelections: function () {
            var canvas_temp, map_data = this.map_data;
            // draw new base canvas, then swap with the old one to avoid flickering
            canvas_temp = map_data.base_canvas;

            map_data.base_canvas = this.createVisibleCanvas(map_data);
            $(map_data.base_canvas).hide();
            $(canvas_temp).before(map_data.base_canvas);

            map_data.redrawSelections();

            $(map_data.base_canvas).show();
            $(canvas_temp).remove();
        }
    };

    vmlMethods = {

        renderShape: function (mapArea, options, cssclass) {
            var me = this, fill, stroke, e, t_fill, el_name, el_class, template, c = mapArea.coords();
            el_name = me.elementName ? 'name="' + me.elementName + '" ' : '';
            el_class = cssclass ? 'class="' + cssclass + '" ' : '';

            t_fill = '<v:fill color="#' + options.fillColor + '" class="_fill" opacity="' +
                (options.fill ?
                    options.fillOpacity :
                    0) +
                '" /><v:stroke class="_fill" opacity="' +
                options.strokeOpacity + '"/>';


            stroke = options.stroke ?
                ' strokeweight=' + options.strokeWidth + ' stroked="t" strokecolor="#' +
                    options.strokeColor + '"' :
                ' stroked="f"';

            fill = options.fill ?
                ' filled="t"' :
                ' filled="f"';

            switch (mapArea.shape) {
                case 'rect':
                    template = '<v:rect ' + el_class + el_name + fill + stroke +
                        ' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:' +
                          c[0] + 'px;top:' + c[1] + 'px;width:' + (c[2] - c[0]) +
                          'px;height:' + (c[3] - c[1]) + 'px;">' + t_fill + '</v:rect>';
                    break;
                case 'poly':
                    template = '<v:shape ' + el_class + el_name + fill + stroke + ' coordorigin="0,0" coordsize="' + me.width + ',' + me.height
                                + '" path="m ' + c[0] + ',' + c[1] + ' l ' + c.slice(2).join(',')
                                + ' x e" style="zoom:1;margin:0;padding:0;display:block;position:absolute;top:0px;left:0px;width:' + me.width + 'px;height:' + me.height + 'px;">' + t_fill + '</v:shape>';
                    break;
                case 'circ':
                case 'circle':
                    template = '<v:oval ' + el_class + el_name + fill + stroke
                                + ' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:' + (c[0] - c[2]) + 'px;top:' + (c[1] - c[2])
                                + 'px;width:' + (c[2] * 2) + 'px;height:' + (c[2] * 2) + 'px;">' + t_fill + '</v:oval>';
                    break;
            }
            e = $(template);
            $(me.canvas).append(e);

            return e;
        },
        render: function () {
            var opts, me = this;

            $.each(this.shapes, function (i, e) {
                me.renderShape(e.mapArea, e.options);
            });

            if (this.masks.length) {
                $.each(this.masks, function (i, e) {
                    opts = u.updateProps({},
                        e.options, {
                            fillOpacity: 1,
                            fillColor: e.options.fillColorMask
                        });
                    me.renderShape(e.mapArea, opts, 'mapster_mask');
                });
            }

            this.active = false;
            return this.canvas;
        },

        createCanvasFor: function (md) {
            var w = md.scaleInfo.width,
                h = md.scaleInfo.height;
            return $('<var width="' + w + '" height="' + h
                + '" style="zoom:1;overflow:hidden;display:block;width:'
                + w + 'px;height:' + h + 'px;"></var>')[0];
        },

        clearHighlight: function () {
            $(this.map_data.overlay_canvas).children().remove();
        },
        // remove single or all selections
        removeSelections: function (area_id) {
            if (area_id >= 0) {
                $(this.map_data.base_canvas).find('[name="static_' + area_id.toString() + '"]').remove();
            }
            else {
                $(this.map_data.base_canvas).children().remove();
            }
        }

    };

    // for all methods with two implemenatations, add a function that will automatically replace itself with the correct
    // method on first invocation

    $.each(['renderShape',
           'addAltImage',
           'render',
           'createCanvasFor',
           'clearHighlight',
           'removeSelections',
           'refreshSelections'],
        function (i, e) {
            p[e] = (function (method) {
                return function () {
                    p[method] = (m.hasCanvas() ?
                        canvasMethods[method] :
                        vmlMethods[method]) || noop;

                    return p[method].apply(this, arguments);
                };
            }(e));
        });


}(jQuery));
/* mapimage.js
   the MapImage object, repesents an instance of a single bound imagemap
*/

(function ($) {

    var m = $.mapster,
        u = m.utils,
        ap = [];
    /**
     * An object encapsulating all the images used by a MapData.
     */

    m.MapImages = function (owner) {
        this.owner = owner;
        this.clear();
    };


    m.MapImages.prototype = {
        constructor: m.MapImages,

        /* interface to make this array-like */

        slice: function () {
            return ap.slice.apply(this, arguments);
        },
        splice: function () {
            ap.slice.apply(this.status, arguments);
            var result = ap.slice.apply(this, arguments);
            return result;
        },

        /**
         * a boolean value indicates whether all images are done loading
         * @return {bool} true when all are done
         */
        complete: function () {
            return $.inArray(false, this.status) < 0;
        },

        /**
         * Save an image in the images array and return its index
         * @param  {Image} image An Image object
         * @return {int} the index of the image
         */

        _add: function (image) {
            var index = ap.push.call(this, image) - 1;
            this.status[index] = false;
            return index;
        },

        /**
         * Return the index of an Image within the images array
         * @param  {Image} img An Image
         * @return {int} the index within the array, or -1 if it was not found
         */

        indexOf: function (image) {
            return $.inArray(image, this);
        },

        /**
         * Clear this object and reset it to its initial state after binding.
         */

        clear: function () {
            var me = this;

            if (me.ids && me.ids.length > 0) {
                $.each(me.ids, function (i, e) {
                    delete me[e];
                });
            }

            /**
             * A list of the cross-reference IDs bound to this object
             * @type {string[]}
             */

            me.ids = [];

            /**
             * Length property for array-like behavior, set to zero when initializing. Array prototype
             * methods will update it after that.
             *
             * @type {int}
             */

            me.length = 0;

            /**
             * the loaded status of the corresponding image
             * @type {boolean[]}
             */

            me.status = [];


            // actually erase the images

            me.splice(0);

        },

        /**
         * Bind an image to the map and add it to the queue to be loaded; return an ID that
         * can be used to reference the
         *
         * @param {Image|string} image An Image object or a URL to an image
         * @param {string} [id] An id to refer to this image
         * @returns {int} an ID referencing the index of the image object in
         *                map_data.images
         */

        add: function (image, id) {
            var index, src, me = this;

            if (!image) { return; }

            if (typeof image === 'string') {
                src = image;
                image = me[src];
                if (typeof image === 'object') {
                    return me.indexOf(image);
                }

                image = $('<img />')
                    .addClass('mapster_el')
                    .hide();

                index = me._add(image[0]);

                image
                    .bind('load', function (e) {
                        me.imageLoaded.call(me, e);
                    })
                    .bind('error', function (e) {
                        me.imageLoadError.call(me, e);
                    });

                image.attr('src', src);
            } else {

                // use attr because we want the actual source, not the resolved path the browser will return directly calling image.src

                index = me._add($(image)[0]);
            }
            if (id) {
                if (this[id]) {
                    throw (id + " is already used or is not available as an altImage alias.");
                }
                me.ids.push(id);
                me[id] = me[index];
            }
            return index;
        },

        /**
         * Bind the images in this object,
         * @param  {boolean} retry when true, indicates that the function is calling itself after failure
         * @return {Promise} a promise that resolves when the images have finished loading
         */

        bind: function (retry) {
            var me = this,
                promise,
                triesLeft = me.owner.options.configTimeout / 200,

            /* A recursive function to continue checking that the images have been
               loaded until a timeout has elapsed */

            check = function () {
                var i;

                // refresh status of images

                i = me.length;

                while (i-- > 0) {
                    if (!me.isLoaded(i)) {
                        break;
                    }
                }

                // check to see if every image has already been loaded

                if (me.complete()) {
                    me.resolve();
                } else {
                    // to account for failure of onLoad to fire in rare situations
                    if (triesLeft-- > 0) {
                        me.imgTimeout = window.setTimeout(function () {
                            check.call(me, true);
                        }, 50);
                    } else {
                        me.imageLoadError.call(me);
                    }
                }

            };

            promise = me.deferred = u.defer();

            check();
            return promise;
        },

        resolve: function () {
            var me = this,
                resolver = me.deferred;

            if (resolver) {
                // Make a copy of the resolver before calling & removing it to ensure
                // it is not called twice
                me.deferred = null;
                resolver.resolve();
            }
        },

        /**
         * Event handler for image onload
         * @param  {object} e jQuery event data
         */

        imageLoaded: function (e) {
            var me = this,
                index = me.indexOf(e.target);

            if (index >= 0) {

                me.status[index] = true;
                if ($.inArray(false, me.status) < 0) {
                    me.resolve();
                }
            }
        },

        /**
         * Event handler for onload error
         * @param  {object} e jQuery event data
         */

        imageLoadError: function (e) {
            clearTimeout(this.imgTimeout);
            this.triesLeft = 0;
            var err = e ? 'The image ' + e.target.src + ' failed to load.' :
                'The images never seemed to finish loading. You may just need to increase the configTimeout if images could take a long time to load.';
            throw err;
        },
        /**
         * Test if the image at specificed index has finished loading
         * @param  {int}  index The image index
         * @return {boolean} true if loaded, false if not
         */

        isLoaded: function (index) {
            var img,
                me = this,
                status = me.status;

            if (status[index]) { return true; }
            img = me[index];

            if (typeof img.complete !== 'undefined') {
                status[index] = img.complete;
            } else {
                status[index] = !!u.imgWidth(img);
            }
            // if complete passes, the image is loaded, but may STILL not be available because of stuff like adblock.
            // make sure it is.

            return status[index];
        }
    };
}(jQuery));
/* mapdata.js
   the MapData object, repesents an instance of a single bound imagemap
*/


(function ($) {

    var m = $.mapster,
        u = m.utils;

    /**
     * Set default values for MapData object properties
     * @param  {MapData} me The MapData object
     */

    function initializeDefaults(me) {
        $.extend(me, {
            complete: false,         // (bool)    when configuration is complete
            map: null,                // ($)      the image map
            base_canvas: null,       // (canvas|var)  where selections are rendered
            overlay_canvas: null,    // (canvas|var)  where highlights are rendered
            commands: [],            // {}        commands that were run before configuration was completed (b/c images weren't loaded)
            data: [],                // MapData[] area groups
            mapAreas: [],            // MapArea[] list. AreaData entities contain refs to this array, so options are stored with each.
            _xref: {},               // (int)      xref of mapKeys to data[]
            highlightId: -1,        // (int)      the currently highlighted element.
            currentAreaId: -1,
            _tooltip_events: [],     // {}         info on events we bound to a tooltip container, so we can properly unbind them
            scaleInfo: null,         // {}         info about the image size, scaling, defaults
            index: -1,                 // index of this in map_cache - so we have an ID to use for wraper div
            activeAreaEvent: null
        });
    }

    /**
     * Return an array of all image-containing options from an options object;
     * that is, containers that may have an "altImage" property
     *
     * @param  {object} obj     An options object
     * @return {object[]}       An array of objects
     */
    function getOptionImages(obj) {
        return [obj, obj.render_highlight, obj.render_select];
    }

    /**
     * Parse all the altImage references, adding them to the library so they can be preloaded
     * and aliased.
     *
     * @param  {MapData} me The MapData object on which to operate
     */
    function configureAltImages(me) {
        var opts = me.options,
            mi = me.images;

        // add alt images

        if (m.hasCanvas()) {
            // map altImage library first

            $.each(opts.altImages || {}, function (i, e) {
                mi.add(e, i);
            });

            // now find everything else

            $.each([opts].concat(opts.areas), function (i, e) {
                $.each(getOptionImages(e), function (i2, e2) {
                    if (e2 && e2.altImage) {
                        e2.altImageId = mi.add(e2.altImage);
                    }
                });
            });
        }

        // set area_options
        me.area_options = u.updateProps({}, // default options for any MapArea
            m.area_defaults,
            opts);
    }

    /**
     * Queue a mouse move action based on current delay settings
     * (helper for mouseover/mouseout handlers)
     *
     * @param  {MapData}    me       The MapData context
     * @param  {number}     delay    The number of milliseconds to delay the action
     * @param  {AreaData}   area     AreaData affected
     * @param  {Deferred}   deferred A deferred object to return (instead of a new one)
     * @return {Promise}    A promise that resolves when the action is completed
     */
    function queueMouseEvent(me, delay, area, deferred) {

        deferred = deferred || u.when.defer();

        function cbFinal(areaId) {
            if (me.currentAreaId !== areaId && me.highlightId >= 0) {
                deferred.resolve();
            }
        }
        if (me.activeAreaEvent) {
            window.clearTimeout(me.activeAreaEvent);
            me.activeAreaEvent = 0;
        }
        if (delay < 0) {
            return;
        }

        if (area.owner.currentAction || delay) {
            me.activeAreaEvent = window.setTimeout((function () {
                return function () {
                    queueMouseEvent(me, 0, area, deferred);
                };
            }(area)),
                delay || 100);
        } else {
            cbFinal(area.areaId);
        }
        return deferred;
    }

    /**
    * Mousedown event. This is captured only to prevent browser from drawing an outline around an
    * area when it's clicked.
    *
    * @param  {EventData} e jQuery event data
    */

    function mousedown(e) {
        if (!m.hasCanvas()) {
            this.blur();
        }
        e.preventDefault();
    }

    /**
     * Mouseover event. Handle highlight rendering and client callback on mouseover
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */

    function mouseover(me, e) {
        var arData = me.getAllDataForArea(this),
            ar = arData.length ? arData[0] : null;

        // mouseover events are ignored entirely while resizing, though we do care about mouseout events
        // and must queue the action to keep things clean.

        if (!ar || ar.isNotRendered() || ar.owner.currentAction) {
            return;
        }

        if (me.currentAreaId === ar.areaId) {
            return;
        }
        if (me.highlightId !== ar.areaId) {
            me.clearEffects();

            ar.highlight();

            if (me.options.showToolTip) {
                $.each(arData, function (i, e) {
                    if (e.effectiveOptions().toolTip) {
                        e.showToolTip();
                    }
                });
            }
        }

        me.currentAreaId = ar.areaId;

        if ($.isFunction(me.options.onMouseover)) {
            me.options.onMouseover.call(this,
            {
                e: e,
                options: ar.effectiveOptions(),
                key: ar.key,
                selected: ar.isSelected()
            });
        }
    }

    /**
     * Mouseout event.
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */

    function mouseout(me, e) {
        var newArea,
            ar = me.getDataForArea(this),
            opts = me.options;


        if (me.currentAreaId < 0 || !ar) {
            return;
        }

        newArea = me.getDataForArea(e.relatedTarget);

        if (newArea === ar) {
            return;
        }

        me.currentAreaId = -1;
        ar.area = null;

        queueMouseEvent(me, opts.mouseoutDelay, ar)
            .then(me.clearEffects);

        if ($.isFunction(opts.onMouseout)) {
            opts.onMouseout.call(this,
            {
                e: e,
                options: opts,
                key: ar.key,
                selected: ar.isSelected()
            });
        }

    }

    /**
     * Clear any active tooltip or highlight
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */

    function clearEffects(me) {
        var opts = me.options;

        me.ensureNoHighlight();

        if (opts.toolTipClose
            && $.inArray('area-mouseout', opts.toolTipClose) >= 0
            && me.activeToolTip) {
            me.clearToolTip();
        }
    }

    /**
     * Mouse click event handler
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */

    function click(me, e) {
        var selected, list, list_target, newSelectionState, canChangeState, cbResult,
            that = this,
            ar = me.getDataForArea(this),
            opts = me.options;

        function clickArea(ar) {
            var areaOpts, target;
            canChangeState = (ar.isSelectable() &&
                (ar.isDeselectable() || !ar.isSelected()));

            if (canChangeState) {
                newSelectionState = !ar.isSelected();
            } else {
                newSelectionState = ar.isSelected();
            }

            list_target = m.getBoundList(opts, ar.key);

            if ($.isFunction(opts.onClick)) {
                cbResult = opts.onClick.call(that,
                {
                    e: e,
                    listTarget: list_target,
                    key: ar.key,
                    selected: newSelectionState
                });

                if (u.isBool(cbResult)) {
                    if (!cbResult) {
                        return false;
                    }
                    target = $(ar.area).attr('href');
                    if (target !== '#') {
                        window.location.href = target;
                        return false;
                    }
                }
            }

            if (canChangeState) {
                selected = ar.toggle();
            }

            if (opts.boundList && opts.boundList.length > 0) {
                m.setBoundListProperties(opts, list_target, ar.isSelected());
            }

            areaOpts = ar.effectiveOptions();
            if (areaOpts.includeKeys) {
                list = u.split(areaOpts.includeKeys);
                $.each(list, function (i, e) {
                    var ar = me.getDataForKey(e.toString());
                    if (!ar.options.isMask) {
                        clickArea(ar);
                    }
                });
            }
        }

        mousedown.call(this, e);

        if (opts.clickNavigate && ar.href) {
            window.location.href = ar.href;
            return;
        }

        if (ar && !ar.owner.currentAction) {
            opts = me.options;
            clickArea(ar);
        }
    }

    /**
     * Prototype for a MapData object, representing an ImageMapster bound object
     * @param {Element} image   an IMG element
     * @param {object} options  ImageMapster binding options
     */
    m.MapData = function (image, options) {
        var me = this;

        // (Image)  main map image

        me.image = image;

        me.images = new m.MapImages(me);
        me.graphics = new m.Graphics(me);

        // save the initial style of the image for unbinding. This is problematic, chrome
        // duplicates styles when assigning, and cssText is apparently not universally supported.
        // Need to do something more robust to make unbinding work universally.

        me.imgCssText = image.style.cssText || null;

        initializeDefaults(me);

        me.configureOptions(options);

        // create context-bound event handlers from our private functions

        me.mouseover = function (e) { mouseover.call(this, me, e); };
        me.mouseout = function (e) { mouseout.call(this, me, e); };
        me.click = function (e) { click.call(this, me, e); };
        me.clearEffects = function (e) { clearEffects.call(this, me, e); };
    };

    m.MapData.prototype = {
        constructor: m.MapData,

        /**
        * Set target.options from defaults + options
        * @param  {[type]} target      The target
        * @param  {[type]} options     The options to merge
        */

        configureOptions: function (options) {
            this.options = u.updateProps({}, m.defaults, options);
        },

        /**
         * Ensure all images are loaded
         * @return {Promise} A promise that resolves when the images have finished loading (or fail)
         */

        bindImages: function () {
            var me = this,
                mi = me.images;

            // reset the images if this is a rebind

            if (mi.length > 2) {
                mi.splice(2);
            } else if (mi.length === 0) {

                // add the actual main image
                mi.add(me.image);
                // will create a duplicate of the main image, we need this to get raw size info
                mi.add(me.image.src);
            }

            configureAltImages(me);

            return me.images.bind();
        },

        /**
         * Test whether an async action is currently in progress
         * @return {Boolean} true or false indicating state
         */

        isActive: function () {
            return !this.complete || this.currentAction;
        },

        /**
         * Return an object indicating the various states. This isn't really used by
         * production code.
         *
         * @return {object} An object with properties for various states
         */

        state: function () {
            return {
                complete: this.complete,
                resizing: this.currentAction === 'resizing',
                zoomed: this.zoomed,
                zoomedArea: this.zoomedArea,
                scaleInfo: this.scaleInfo
            };
        },

        /**
         * Get a unique ID for the wrapper of this imagemapster
         * @return {string} A string that is unique to this image
         */

        wrapId: function () {
            return 'mapster_wrap_' + this.index;
        },
        _idFromKey: function (key) {
            return typeof key === "string" && this._xref.hasOwnProperty(key) ?
                        this._xref[key] : -1;
        },

        /**
         * Return a comma-separated string of all selected keys
         * @return {string} CSV of all keys that are currently selected
         */

        getSelected: function () {
            var result = '';
            $.each(this.data, function (i, e) {
                if (e.isSelected()) {
                    result += (result ? ',' : '') + this.key;
                }
            });
            return result;
        },

        /**
         * Get an array of MapAreas associated with a specific AREA based on the keys for that area
         * @param  {Element} area   An HTML AREA
         * @param  {number} atMost  A number limiting the number of areas to be returned (typically 1 or 0 for no limit)
         * @return {MapArea[]}      Array of MapArea objects
         */

        getAllDataForArea: function (area, atMost) {
            var i, ar, result,
                me = this,
                key = $(area).filter('area').attr(me.options.mapKey);

            if (key) {
                result = [];
                key = u.split(key);

                for (i = 0; i < (atMost || key.length) ; i++) {
                    ar = me.data[me._idFromKey(key[i])];
                    ar.area = area.length ? area[0] : area;
                    // set the actual area moused over/selected
                    // TODO: this is a brittle model for capturing which specific area - if this method was not used,
                    // ar.area could have old data. fix this.
                    result.push(ar);
                }
            }

            return result;
        },
        getDataForArea: function (area) {
            var ar = this.getAllDataForArea(area, 1);
            return ar ? ar[0] || null : null;
        },
        getDataForKey: function (key) {
            return this.data[this._idFromKey(key)];
        },

        /**
         * Get the primary keys associated with an area group.
         * If this is a primary key, it will be returned.
         *
         * @param  {string key An area key
         * @return {string} A CSV of area keys
         */

        getKeysForGroup: function (key) {
            var ar = this.getDataForKey(key);

            return !ar ? '' :
                ar.isPrimary ?
                    ar.key :
                    this.getPrimaryKeysForMapAreas(ar.areas()).join(',');
        },

        /**
         * given an array of MapArea object, return an array of its unique primary keys
         * @param  {MapArea[]} areas The areas to analyze
         * @return {string[]} An array of unique primary keys
         */

        getPrimaryKeysForMapAreas: function (areas) {
            var keys = [];
            $.each(areas, function (i, e) {
                if ($.inArray(e.keys[0], keys) < 0) {
                    keys.push(e.keys[0]);
                }
            });
            return keys;
        },
        getData: function (obj) {
            if (typeof obj === 'string') {
                return this.getDataForKey(obj);
            } else if (obj && obj.mapster || u.isElement(obj)) {
                return this.getDataForArea(obj);
            } else {
                return null;
            }
        },
        // remove highlight if present, raise event
        ensureNoHighlight: function () {
            var ar;
            if (this.highlightId >= 0) {
                this.graphics.clearHighlight();
                ar = this.data[this.highlightId];
                ar.changeState('highlight', false);
                this.setHighlightId(-1);
            }
        },
        setHighlightId: function (id) {
            this.highlightId = id;
        },

        /**
         * Clear all active selections on this map
         */

        clearSelections: function () {
            $.each(this.data, function (i, e) {
                if (e.selected) {
                    e.deselect(true);
                }
            });
            this.removeSelectionFinish();

        },

        /**
         * Set area options from an array of option data.
         *
         * @param {object[]} areas An array of objects containing area-specific options
         */

        setAreaOptions: function (areas) {
            var i, area_options, ar;
            areas = areas || [];

            // refer by: map_data.options[map_data.data[x].area_option_id]

            for (i = areas.length - 1; i >= 0; i--) {
                area_options = areas[i];
                if (area_options) {
                    ar = this.getDataForKey(area_options.key);
                    if (ar) {
                        u.updateProps(ar.options, area_options);

                        // TODO: will not deselect areas that were previously selected, so this only works
                        // for an initial bind.

                        if (u.isBool(area_options.selected)) {
                            ar.selected = area_options.selected;
                        }
                    }
                }
            }
        },
        // keys: a comma-separated list
        drawSelections: function (keys) {
            var i, key_arr = u.asArray(keys);

            for (i = key_arr.length - 1; i >= 0; i--) {
                this.data[key_arr[i]].drawSelection();
            }
        },
        redrawSelections: function () {
            $.each(this.data, function (i, e) {
                if (e.isSelectedOrStatic()) {
                    e.drawSelection();
                }
            });

        },
        ///called when images are done loading
        initialize: function () {
            var imgCopy, base_canvas, overlay_canvas, wrap, parentId, css, i, size,
                img, sort_func, sorted_list, scale,
                        me = this,
                        opts = me.options;

            if (me.complete) {
                return;
            }

            img = $(me.image);

            parentId = img.parent().attr('id');

            // create a div wrapper only if there's not already a wrapper, otherwise, own it

            if (parentId && parentId.length >= 12 && parentId.substring(0, 12) === "mapster_wrap") {
                wrap = img.parent();
                wrap.attr('id', me.wrapId());
            } else {
                wrap = $('<div id="' + me.wrapId() + '"></div>');

                if (opts.wrapClass) {
                    if (opts.wrapClass === true) {
                        wrap.addClass(img[0].className);
                    }
                    else {
                        wrap.addClass(opts.wrapClass);
                    }
                }
            }
            me.wrapper = wrap;

            // me.images[1] is the copy of the original image. It should be loaded & at its native size now so we can obtain the true
            // width & height. This is needed to scale the imagemap if not being shown at its native size. It is also needed purely
            // to finish binding in case the original image was not visible. It can be impossible in some browsers to obtain the
            // native size of a hidden image.

            me.scaleInfo = scale = u.scaleMap(me.images[0], me.images[1], opts.scaleMap);

            me.base_canvas = base_canvas = me.graphics.createVisibleCanvas(me);
            me.overlay_canvas = overlay_canvas = me.graphics.createVisibleCanvas(me);

            // Now we got what we needed from the copy -clone from the original image again to make sure any other attributes are copied
            imgCopy = $(me.images[1])
                .addClass('mapster_el ' + me.images[0].className)
                .attr({ id: null, usemap: null });

            size = u.size(me.images[0]);

            if (size.complete) {
                imgCopy.css({
                    width: size.width,
                    height: size.height
                });
            }

            me.buildDataset();

            // now that we have processed all the areas, set css for wrapper, scale map if needed

            css = {
                display: 'block',
                position: 'relative',
                padding: 0,
                width: scale.width,
                height: scale.height
            };

            if (opts.wrapCss) {
                $.extend(css, opts.wrapCss);
            }
            // if we were rebinding with an existing wrapper, the image will aready be in it
            if (img.parent()[0] !== me.wrapper[0]) {

                img.before(me.wrapper);
            }

            wrap.css(css);

            // move all generated images into the wrapper for easy removal later

            $(me.images.slice(2)).hide();
            for (i = 1; i < me.images.length; i++) {
                wrap.append(me.images[i]);
            }

            //me.images[1].style.cssText = me.image.style.cssText;

            wrap.append(base_canvas)
                        .append(overlay_canvas)
                        .append(img.css(m.canvas_style));

            // images[0] is the original image with map, images[1] is the copy/background that is visible

            u.setOpacity(me.images[0], 0);
            $(me.images[1]).show();

            u.setOpacity(me.images[1], 1);

            if (opts.isSelectable && opts.onGetList) {
                sorted_list = me.data.slice(0);
                if (opts.sortList) {
                    if (opts.sortList === "desc") {
                        sort_func = function (a, b) {
                            return a === b ? 0 : (a > b ? -1 : 1);
                        };
                    }
                    else {
                        sort_func = function (a, b) {
                            return a === b ? 0 : (a < b ? -1 : 1);
                        };
                    }

                    sorted_list.sort(function (a, b) {
                        a = a.value;
                        b = b.value;
                        return sort_func(a, b);
                    });
                }

                me.options.boundList = opts.onGetList.call(me.image, sorted_list);
            }

            me.complete = true;
            me.processCommandQueue();

            if (opts.onConfigured && typeof opts.onConfigured === 'function') {
                opts.onConfigured.call(img, true);
            }
        },

        // when rebind is true, the MapArea data will not be rebuilt.
        buildDataset: function (rebind) {
            var sel, areas, j, area_id, $area, area, curKey, mapArea, key, keys, mapAreaId, group_value, dataItem, href,
                me = this,
                opts = me.options,
                default_group;

            function addAreaData(key, value) {
                var dataItem = new m.AreaData(me, key, value);
                dataItem.areaId = me._xref[key] = me.data.push(dataItem) - 1;
                return dataItem.areaId;
            }

            me._xref = {};
            me.data = [];
            if (!rebind) {
                me.mapAreas = [];
            }

            default_group = !opts.mapKey;
            if (default_group) {
                opts.mapKey = 'data-mapster-key';
            }

            // the [attribute] selector is broken on old IE with jQuery. hasVml() is a quick and dirty
            // way to test for that

            sel = m.hasVml() ? 'area' :
                        (default_group ?
                            'area[coords]' :
                            'area[' + opts.mapKey + ']');

            areas = $(me.map).find(sel).unbind('.mapster');

            for (mapAreaId = 0; mapAreaId < areas.length; mapAreaId++) {
                area_id = 0;
                area = areas[mapAreaId];
                $area = $(area);

                // skip areas with no coords - selector broken for older ie
                if (!area.coords) {
                    continue;
                }
                // Create a key if none was assigned by the user

                if (default_group) {
                    curKey = String(mapAreaId);
                    $area.attr('data-mapster-key', curKey);

                } else {
                    curKey = area.getAttribute(opts.mapKey);
                }

                // conditions for which the area will be bound to mouse events
                // only bind to areas that don't have nohref. ie 6&7 cannot detect the presence of nohref, so we have to also not bind if href is missing.

                if (rebind) {
                    mapArea = me.mapAreas[$area.data('mapster') - 1];
                    mapArea.configure(curKey);
                } else {
                    mapArea = new m.MapArea(me, area, curKey);
                    me.mapAreas.push(mapArea);
                }

                keys = mapArea.keys; // converted to an array by mapArea


                // Iterate through each mapKey assigned to this area
                for (j = keys.length - 1; j >= 0; j--) {
                    key = keys[j];

                    if (opts.mapValue) {
                        group_value = $area.attr(opts.mapValue);
                    }
                    if (default_group) {
                        // set an attribute so we can refer to the area by index from the DOM object if no key
                        area_id = addAreaData(me.data.length, group_value);
                        dataItem = me.data[area_id];
                        dataItem.key = key = area_id.toString();
                    }
                    else {
                        area_id = me._xref[key];
                        if (area_id >= 0) {
                            dataItem = me.data[area_id];
                            if (group_value && !me.data[area_id].value) {
                                dataItem.value = group_value;
                            }
                        }
                        else {
                            area_id = addAreaData(key, group_value);
                            dataItem = me.data[area_id];
                            dataItem.isPrimary = j === 0;
                        }
                    }
                    mapArea.areaDataXref.push(area_id);
                    dataItem.areasXref.push(mapAreaId);
                }

                href = $area.attr('href');
                if (href && href !== '#' && !dataItem.href) {
                    dataItem.href = href;
                }

                if (!mapArea.nohref) {
                    $area.bind('click.mapster', me.click);

                    if (!m.isTouch) {
                        $area.bind('mouseover.mapster', me.mouseover)
                            .bind('mouseout.mapster', me.mouseout)
                            .bind('mousedown.mapster', me.mousedown);

                    }

                }

                // store an ID with each area.
                $area.data("mapster", mapAreaId + 1);
            }

            // TODO listenToList
            //            if (opts.listenToList && opts.nitG) {
            //                opts.nitG.bind('click.mapster', event_hooks[map_data.hooks_index].listclick_hook);
            //            }

            // populate areas from config options
            me.setAreaOptions(opts.areas);
            me.redrawSelections();

        },
        processCommandQueue: function () {

            var cur, me = this;
            while (!me.currentAction && me.commands.length) {
                cur = me.commands[0];
                me.commands.splice(0, 1);
                m.impl[cur.command].apply(cur.that, cur.args);
            }
        },
        clearEvents: function () {
            $(this.map).find('area')
                        .unbind('.mapster');
            $(this.images)
                        .unbind('.mapster');
        },
        _clearCanvases: function (preserveState) {
            // remove the canvas elements created
            if (!preserveState) {
                $(this.base_canvas).remove();
            }
            $(this.overlay_canvas).remove();
        },
        clearMapData: function (preserveState) {
            var me = this;
            this._clearCanvases(preserveState);

            // release refs to DOM elements
            $.each(this.data, function (i, e) {
                e.reset();
            });
            this.data = null;
            if (!preserveState) {
                // get rid of everything except the original image
                this.image.style.cssText = this.imgCssText;
                $(this.wrapper).before(this.image).remove();
            }

            me.images.clear();

            this.image = null;
            u.ifFunction(this.clearTooltip, this);
        },

        // Compelete cleanup process for deslecting items. Called after a batch operation, or by AreaData for single
        // operations not flagged as "partial"

        removeSelectionFinish: function () {
            var g = this.graphics;

            g.refreshSelections();
            // do not call ensure_no_highlight- we don't really want to unhilight it, just remove the effect
            g.clearHighlight();
        }
    };
}(jQuery));
/* areadata.js
   AreaData and MapArea protoypes
*/

(function ($) {
    var m = $.mapster, u = m.utils;

    /**
     * Select this area
     *
     * @param {AreaData} me  AreaData context
     * @param {object} options Options for rendering the selection
     */
    function select(options) {
        // need to add the new one first so that the double-opacity effect leaves the current one highlighted for singleSelect

        var me = this, o = me.owner;
        if (o.options.singleSelect) {
            o.clearSelections();
        }

        // because areas can overlap - we can't depend on the selection state to tell us anything about the inner areas.
        // don't check if it's already selected
        if (!me.isSelected()) {
            if (options) {

                // cache the current options, and map the altImageId if an altimage
                // was passed

                me.optsCache = $.extend(me.effectiveRenderOptions('select'),
                    options,
                    {
                        altImageId: o.images.add(options.altImage)
                    });
            }

            me.drawSelection();

            me.selected = true;
            me.changeState('select', true);
        }

        if (o.options.singleSelect) {
            o.graphics.refreshSelections();
        }
    }

    /**
     * Deselect this area, optionally deferring finalization so additional areas can be deselected
     * in a single operation
     *
     * @param  {boolean} partial when true, the caller must invoke "finishRemoveSelection" to render
     */

    function deselect(partial) {
        var me = this;
        me.selected = false;
        me.changeState('select', false);

        // release information about last area options when deselecting.

        me.optsCache = null;
        me.owner.graphics.removeSelections(me.areaId);

        // Complete selection removal process. This is separated because it's very inefficient to perform the whole
        // process for multiple removals, as the canvas must be totally redrawn at the end of the process.ar.remove

        if (!partial) {
            me.owner.removeSelectionFinish();
        }
    }

    /**
     * Toggle the selection state of this area
     * @param  {object} options Rendering options, if toggling on
     * @return {bool} The new selection state
     */
    function toggle(options) {
        var me = this;
        if (!me.isSelected()) {
            me.select(options);
        }
        else {
            me.deselect();
        }
        return me.isSelected();
    }

    /**
     * An AreaData object; represents a conceptual area that can be composed of
     * one or more MapArea objects
     *
     * @param {MapData} owner The MapData object to which this belongs
     * @param {string} key   The key for this area
     * @param {string} value The mapValue string for this area
     */

    m.AreaData = function (owner, key, value) {
        $.extend(this, {
            owner: owner,
            key: key || '',
            // means this represents the first key in a list of keys (it's the area group that gets highlighted on mouseover)
            isPrimary: true,
            areaId: -1,
            href: '',
            value: value || '',
            options: {},
            // "null" means unchanged. Use "isSelected" method to just test true/false
            selected: null,
            // xref to MapArea objects
            areasXref: [],
            // (temporary storage) - the actual area moused over
            area: null,
            // the last options used to render this. Cache so when re-drawing after a remove, changes in options won't
            // break already selected things.
            optsCache: null
        });
    };

    /**
     * The public API for AreaData object
     */

    m.AreaData.prototype = {
        constuctor: m.AreaData,
        select: select,
        deselect: deselect,
        toggle: toggle,
        areas: function () {
            var i, result = [];
            for (i = 0; i < this.areasXref.length; i++) {
                result.push(this.owner.mapAreas[this.areasXref[i]]);
            }
            return result;
        },
        // return all coordinates for all areas
        coords: function (offset) {
            var coords = [];
            $.each(this.areas(), function (i, el) {
                coords = coords.concat(el.coords(offset));
            });
            return coords;
        },
        reset: function () {
            $.each(this.areas(), function (i, e) {
                e.reset();
            });
            this.areasXref = [];
            this.options = null;
        },
        // Return the effective selected state of an area, incorporating staticState
        isSelectedOrStatic: function () {

            var o = this.effectiveOptions();
            return u.isBool(o.staticState) ? o.staticState :
                        this.isSelected();
        },
        isSelected: function () {
            return u.isBool(this.selected) ? this.selected :
                u.isBool(this.owner.area_options.selected) ? this.owner.area_options.selected : false;
        },
        isSelectable: function () {
            return u.isBool(this.effectiveOptions().staticState) ? false :
                        (u.isBool(this.owner.options.staticState) ? false : u.boolOrDefault(this.effectiveOptions().isSelectable, true));
        },
        isDeselectable: function () {
            return u.isBool(this.effectiveOptions().staticState) ? false :
                        (u.isBool(this.owner.options.staticState) ? false : u.boolOrDefault(this.effectiveOptions().isDeselectable, true));
        },
        isNotRendered: function () {
            var area = $(this.area);
            return area.attr('nohref') ||
                !area.attr('href') ||
                this.effectiveOptions().isMask;

        },


        /**
        * Return the overall options effective for this area.
        * This should get the default options, and merge in area-specific options, finally
        * overlaying options passed by parameter
        *
        * @param  {[type]} options  options which will supercede all other options for this area
        * @return {[type]}          the combined options
        */

        effectiveOptions: function (options) {

            var opts = u.updateProps({},
                    this.owner.area_options,
                    this.options,
                    options || {},
                    {
                        id: this.areaId
                    }
                );

            opts.selected = this.isSelected();

            return opts;
        },

        /**
         * Return the options effective for this area for a "render" or "highlight" mode.
         * This should get the default options, merge in the areas-specific options,
         * and then the mode-specific options.
         * @param  {string} mode    'render' or 'highlight'
         * @param  {[type]} options  options which will supercede all other options for this area
         * @return {[type]}          the combined options
         */

        effectiveRenderOptions: function (mode, options) {
            var allOpts, opts = this.optsCache;

            if (!opts || mode === 'highlight') {
                allOpts = this.effectiveOptions(options);
                opts = u.updateProps({},
                    allOpts,
                    allOpts["render_" + mode]
                );

                if (mode !== 'highlight') {
                    this.optsCache = opts;
                }
            }
            return $.extend({}, opts);
        },

        // Fire callback on area state change
        changeState: function (state_type, state) {
            if ($.isFunction(this.owner.options.onStateChange)) {
                this.owner.options.onStateChange.call(this.owner.image,
                    {
                        key: this.key,
                        state: state_type,
                        selected: state
                    }
                );
            }
        },

        // highlight this area

        highlight: function (options) {
            var o = this.owner;
            if (this.effectiveOptions().highlight) {
                o.graphics.addShapeGroup(this, "highlight", options);
            }
            o.setHighlightId(this.areaId);
            this.changeState('highlight', true);
        },

        // select this area. if "callEvent" is true then the state change event will be called. (This method can be used
        // during config operations, in which case no event is indicated)

        drawSelection: function () {


            this.owner.graphics.addShapeGroup(this, "select");

        }


    };
    // represents an HTML area
    m.MapArea = function (owner, areaEl, keys) {
        if (!owner) {
            return;
        }
        var me = this;
        me.owner = owner;   // a MapData object
        me.area = areaEl;
        me.areaDataXref = []; // a list of map_data.data[] id's for each areaData object containing this
        me.originalCoords = [];
        $.each(u.split(areaEl.coords), function (i, el) {
            me.originalCoords.push(parseFloat(el));
        });
        me.length = me.originalCoords.length;
        me.shape = areaEl.shape.toLowerCase();
        me.nohref = areaEl.nohref || !areaEl.href;
        me.configure(keys);
    };
    m.MapArea.prototype = {
        constructor: m.MapArea,
        configure: function (keys) {
            this.keys = u.split(keys);
        },
        reset: function () {
            this.area = null;
        },
        coords: function (offset) {
            return $.map(this.originalCoords, function (e) {
                return offset ? e : e + offset;
            });
        }
    };
}(jQuery));
/* areacorners.js
   determine the best place to put a box of dimensions (width,height) given a circle, rect or poly
*/

(function ($) {
    var u = $.mapster.utils;


    /**
     * Compute positions that will place a target with dimensions [width,height] outside
     * but near the boundaries of the elements "elements". When an imagemap is passed, the
     *
     * @param  {Element|Element[]} elements An element or an array of elements (such as a jQuery object)
     * @param  {Element} image The image to which area elements are bound, if this is an image map.
     * @param  {Element} container The contianer in which the target must be constrained (or document, if missing)
     * @param  {int} width The width of the target object
     * @return {object} a structure with the x and y positions
     */
    u.areaCorners = function (elements, image, container, width, height) {
        var pos, found, minX, minY, maxX, maxY, bestMinX, bestMaxX, bestMinY, bestMaxY, curX, curY, nest, j,
           offsetx = 0,
           offsety = 0,
           rootx,
           rooty,
           iCoords, radius, angle, el,
           coords = [];

        // if a single element was passed, map it to an array

        elements = elements.length ?
            elements :
            [elements];

        container = container ?
            $(container) :
            $(document.body);

        // get the relative root of calculation

        pos = container.offset();
        rootx = pos.left;
        rooty = pos.top;

        // with areas, all we know about is relative to the top-left corner of the image. We need to add an offset compared to
        // the actual container. After this calculation, offsetx/offsety can be added to either the area coords, or the target's
        // absolute position to get the correct top/left boundaries of the container.

        if (image) {
            pos = $(image).offset();
            offsetx = pos.left;
            offsety = pos.top;
        }

        // map the coordinates of any type of shape to a poly and use the logic. simpler than using three different
        // calculation methods. Circles use a 20 degree increment for this estimation.

        for (j = 0; j < elements.length; j++) {
            el = elements[j];
            if (el.nodeName === 'AREA') {
                iCoords = u.split(el.coords, parseInt);

                switch (el.shape) {
                    case 'circle':
                        curX = iCoords[0];
                        curY = iCoords[1];
                        radius = iCoords[2];
                        coords = [];
                        for (j = 0; j < 360; j += 20) {
                            angle = j * Math.PI / 180;
                            coords.push(curX + radius * Math.cos(angle), curY + radius * Math.sin(angle));
                        }
                        break;
                    case 'rect':
                        coords.push(iCoords[0], iCoords[1], iCoords[2], iCoords[1], iCoords[2], iCoords[3], iCoords[0], iCoords[3]);
                        break;
                    default:
                        coords = coords.concat(iCoords);
                        break;
                }

                // map area positions to it's real position in the container

                for (j = 0; j < coords.length; j += 2) {
                    coords[j] = parseInt(coords[j], 10) + offsetx;
                    coords[j + 1] = parseInt(coords[j + 1], 10) + offsety;
                }
            } else {
                el = $(el);
                pos = el.position();
                coords.push(pos.left, pos.top,
                            pos.left + el.width(), pos.top,
                            pos.left + el.width(), pos.top + el.height(),
                            pos.left, pos.top + el.height());

            }
        }

        minX = minY = bestMinX = bestMinY = 999999;
        maxX = maxY = bestMaxX = bestMaxY = -1;

        for (j = coords.length - 2; j >= 0; j -= 2) {
            curX = coords[j];
            curY = coords[j + 1];

            if (curX < minX) {
                minX = curX;
                bestMaxY = curY;
            }
            if (curX > maxX) {
                maxX = curX;
                bestMinY = curY;
            }
            if (curY < minY) {
                minY = curY;
                bestMaxX = curX;
            }
            if (curY > maxY) {
                maxY = curY;
                bestMinX = curX;
            }

        }

        // try to figure out the best place for the tooltip

        if (width && height) {
            found = false;
            $.each([[bestMaxX - width, minY - height], [bestMinX, minY - height],
                             [minX - width, bestMaxY - height], [minX - width, bestMinY],
                             [maxX, bestMaxY - height], [maxX, bestMinY],
                             [bestMaxX - width, maxY], [bestMinX, maxY]
            ], function (i, e) {
                if (!found && (e[0] > rootx && e[1] > rooty)) {
                    nest = e;
                    found = true;
                    return false;
                }
            });

            // default to lower-right corner if nothing fit inside the boundaries of the image

            if (!found) {
                nest = [maxX, maxY];
            }
        }
        return nest;
    };
}(jQuery));
/* scale.js: resize and zoom functionality
   requires areacorners.js, when.js
*/


(function ($) {
    var m = $.mapster, u = m.utils, p = m.MapArea.prototype;

    m.utils.getScaleInfo = function (eff, actual) {
        var pct;
        if (!actual) {
            pct = 1;
            actual = eff;
        } else {
            pct = eff.width / actual.width || eff.height / actual.height;
            // make sure a float error doesn't muck us up
            if (pct > 0.98 && pct < 1.02) { pct = 1; }
        }
        return {
            scale: (pct !== 1),
            scalePct: pct,
            realWidth: actual.width,
            realHeight: actual.height,
            width: eff.width,
            height: eff.height,
            ratio: eff.width / eff.height
        };
    };
    // Scale a set of AREAs, return old data as an array of objects
    m.utils.scaleMap = function (image, imageRaw, scale) {

        // stunningly, jQuery width can return zero even as width does not, seems to happen only
        // with adBlock or maybe other plugins. These must interfere with onload events somehow.


        var vis = u.size(image),
            raw = u.size(imageRaw, true);

        if (!raw.complete()) {
            throw ("Another script, such as an extension, appears to be interfering with image loading. Please let us know about this.");
        }
        if (!vis.complete()) {
            vis = raw;
        }
        return this.getScaleInfo(vis, scale ? raw : null);
    };

    /**
     * Resize the image map. Only one of newWidth and newHeight should be passed to preserve scale
     *
     * @param  {int}   width       The new width OR an object containing named parameters matching this function sig
     * @param  {int}   height      The new height
     * @param  {int}   effectDuration Time in ms for the resize animation, or zero for no animation
     * @param  {function} callback    A function to invoke when the operation finishes
     * @return {promise}              NOT YET IMPLEMENTED
     */

    m.MapData.prototype.resize = function (width, height, duration, callback) {
        var p, promises, newsize, els, highlightId, ratio,
            me = this;

        // allow omitting duration
        callback = callback || duration;

        function sizeCanvas(canvas, w, h) {
            if (m.hasCanvas()) {
                canvas.width = w;
                canvas.height = h;
            } else {
                $(canvas).width(w);
                $(canvas).height(h);
            }
        }

        // Finalize resize action, do callback, pass control to command queue

        function cleanupAndNotify() {

            me.currentAction = '';

            if ($.isFunction(callback)) {
                callback();
            }

            me.processCommandQueue();
        }

        // handle cleanup after the inner elements are resized

        function finishResize() {
            sizeCanvas(me.overlay_canvas, width, height);

            // restore highlight state if it was highlighted before
            if (highlightId >= 0) {
                var areaData = me.data[highlightId];
                areaData.tempOptions = { fade: false };
                me.getDataForKey(areaData.key).highlight();
                areaData.tempOptions = null;
            }
            sizeCanvas(me.base_canvas, width, height);
            me.redrawSelections();
            cleanupAndNotify();
        }

        function resizeMapData() {
            $(me.image).css(newsize);
            // start calculation at the same time as effect
            me.scaleInfo = u.getScaleInfo({
                width: width,
                height: height
            },
                {
                    width: me.scaleInfo.realWidth,
                    height: me.scaleInfo.realHeight
                });
            $.each(me.data, function (i, e) {
                $.each(e.areas(), function (i, e) {
                    e.resize();
                });
            });
        }

        if (me.scaleInfo.width === width && me.scaleInfo.height === height) {
            return;
        }

        highlightId = me.highlightId;


        if (!width) {
            ratio = height / me.scaleInfo.realHeight;
            width = Math.round(me.scaleInfo.realWidth * ratio);
        }
        if (!height) {
            ratio = width / me.scaleInfo.realWidth;
            height = Math.round(me.scaleInfo.realHeight * ratio);
        }

        newsize = { 'width': String(width) + 'px', 'height': String(height) + 'px' };
        if (!m.hasCanvas()) {
            $(me.base_canvas).children().remove();
        }

        // resize all the elements that are part of the map except the image itself (which is not visible)
        // but including the div wrapper
        els = $(me.wrapper).find('.mapster_el').add(me.wrapper);

        if (duration) {
            promises = [];
            me.currentAction = 'resizing';
            els.each(function (i, e) {
                p = u.defer();
                promises.push(p);

                $(e).animate(newsize, {
                    duration: duration,
                    complete: p.resolve,
                    easing: "linear"
                });
            });

            p = u.defer();
            promises.push(p);

            // though resizeMapData is not async, it needs to be finished just the same as the animations,
            // so add it to the "to do" list.

            u.when.all(promises).then(finishResize);
            resizeMapData();
            p.resolve();
        } else {
            els.css(newsize);
            resizeMapData();
            finishResize();

        }
    };


    m.MapArea = u.subclass(m.MapArea, function () {
        //change the area tag data if needed
        this.base.init();
        if (this.owner.scaleInfo.scale) {
            this.resize();
        }
    });

    p.coords = function (percent, coordOffset) {
        var j, newCoords = [],
                    pct = percent || this.owner.scaleInfo.scalePct,
                    offset = coordOffset || 0;

        if (pct === 1 && coordOffset === 0) {
            return this.originalCoords;
        }

        for (j = 0; j < this.length; j++) {
            //amount = j % 2 === 0 ? xPct : yPct;
            newCoords.push(Math.round(this.originalCoords[j] * pct) + offset);
        }
        return newCoords;
    };
    p.resize = function () {
        this.area.coords = this.coords().join(',');
    };

    p.reset = function () {
        this.area.coords = this.coords(1).join(',');
    };

    m.impl.resize = function (width, height, duration, callback) {
        if (!width && !height) {
            return false;
        }
        var x = (new m.Method(this,
                function () {
                    this.resize(width, height, duration, callback);
                },
                null,
                {
                    name: 'resize',
                    args: arguments
                }
            )).go();
        return x;
    };

    /*
        m.impl.zoom = function (key, opts) {
            var options = opts || {};

            function zoom(areaData) {
                // this will be MapData object returned by Method

                var scroll, corners, height, width, ratio,
                        diffX, diffY, ratioX, ratioY, offsetX, offsetY, newWidth, newHeight, scrollLeft, scrollTop,
                        padding = options.padding || 0,
                        scrollBarSize = areaData ? 20 : 0,
                        me = this,
                        zoomOut = false;

                if (areaData) {
                    // save original state on first zoom operation
                    if (!me.zoomed) {
                        me.zoomed = true;
                        me.preZoomWidth = me.scaleInfo.width;
                        me.preZoomHeight = me.scaleInfo.height;
                        me.zoomedArea = areaData;
                        if (options.scroll) {
                            me.wrapper.css({ overflow: 'auto' });
                        }
                    }
                    corners = $.mapster.utils.areaCorners(areaData.coords(1, 0));
                    width = me.wrapper.innerWidth() - scrollBarSize - padding * 2;
                    height = me.wrapper.innerHeight() - scrollBarSize - padding * 2;
                    diffX = corners.maxX - corners.minX;
                    diffY = corners.maxY - corners.minY;
                    ratioX = width / diffX;
                    ratioY = height / diffY;
                    ratio = Math.min(ratioX, ratioY);
                    offsetX = (width - diffX * ratio) / 2;
                    offsetY = (height - diffY * ratio) / 2;

                    newWidth = me.scaleInfo.realWidth * ratio;
                    newHeight = me.scaleInfo.realHeight * ratio;
                    scrollLeft = (corners.minX) * ratio - padding - offsetX;
                    scrollTop = (corners.minY) * ratio - padding - offsetY;
                } else {
                    if (!me.zoomed) {
                        return;
                    }
                    zoomOut = true;
                    newWidth = me.preZoomWidth;
                    newHeight = me.preZoomHeight;
                    scrollLeft = null;
                    scrollTop = null;
                }

                this.resize({
                    width: newWidth,
                    height: newHeight,
                    duration: options.duration,
                    scroll: scroll,
                    scrollLeft: scrollLeft,
                    scrollTop: scrollTop,
                    // closure so we can be sure values are correct
                    callback: (function () {
                        var isZoomOut = zoomOut,
                                scroll = options.scroll,
                                areaD = areaData;
                        return function () {
                            if (isZoomOut) {
                                me.preZoomWidth = null;
                                me.preZoomHeight = null;
                                me.zoomed = false;
                                me.zoomedArea = false;
                                if (scroll) {
                                    me.wrapper.css({ overflow: 'inherit' });
                                }
                            } else {
                                // just to be sure it wasn't canceled & restarted
                                me.zoomedArea = areaD;
                            }
                        };
                    } ())
                });
            }
            return (new m.Method(this,
                    function (opts) {
                        zoom.call(this);
                    },
                    function () {
                        zoom.call(this.owner, this);
                    },
                    {
                        name: 'zoom',
                        args: arguments,
                        first: true,
                        key: key
                    }
                    )).go();


        };
        */
}(jQuery));
/* tooltip.js - tooltip functionality
   requires areacorners.js
*/

(function ($) {

    var m = $.mapster, u = m.utils;

    $.extend(m.defaults, {
        toolTipContainer: '<div style="border: 2px solid black; background: #EEEEEE; width:160px; padding:4px; margin: 4px; -moz-box-shadow: 3px 3px 5px #535353; ' +
        '-webkit-box-shadow: 3px 3px 5px #535353; box-shadow: 3px 3px 5px #535353; -moz-border-radius: 6px 6px 6px 6px; -webkit-border-radius: 6px; ' +
        'border-radius: 6px 6px 6px 6px; opacity: 0.9;"></dteniv>',
        showToolTip: false,
        toolTipFade: true,
        toolTipClose: ['area-mouseout', 'image-mouseout'],
        onShowToolTip: null,
        onHideToolTip: null
    });

    $.extend(m.area_defaults, {
        toolTip: null,
        toolTipClose: null
    });


    /**
     * Show a tooltip positioned near this area.
     *
     * @param {string|jquery} html A string of html or a jQuery object containing the tooltip content.
     * @param {string|jquery} [template] The html template in which to wrap the content
     * @param {string|object} [css] CSS to apply to the outermost element of the tooltip
     * @return {jquery} The tooltip that was created
     */

    function createToolTip(html, template, css) {
        var tooltip;

        // wrap the template in a jQuery object, or clone the template if it's already one.
        // This assumes that anything other than a string is a jQuery object; if it's not jQuery will
        // probably throw an error.

        if (template) {
            tooltip = typeof template === 'string' ?
                $(template) :
                $(template).clone();

            tooltip.append(html);
        } else {
            tooltip = $(html);
        }

        // always set display to block, or the positioning css won't work if the end user happened to
        // use a non-block type element.

        tooltip.css($.extend((css || {}), {
            display: "block",
            position: "absolute"
        })).hide();

        $('body').append(tooltip);

        // we must actually add the tooltip to the DOM and "show" it in order to figure out how much space it
        // consumes, and then reposition it with that knowledge.
        // We also cache the actual opacity setting to restore finally.

        tooltip.attr("data-opacity", tooltip.css("opacity"))
            .css("opacity", 0);

        // doesn't really show it because opacity=0

        return tooltip.show();
    }


    /**
     * Show a tooltip positioned near this area.
     *
     * @param {jquery} tooltip The tooltip
     * @param {object} [options] options for displaying the tooltip.
     *  @config {int} [left] The 0-based absolute x position for the tooltip
     *  @config {int} [top] The 0-based absolute y position for the tooltip
     *  @config {string|object} [css] CSS to apply to the outermost element of the tooltip
     *  @config {bool} [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
     */

    function showToolTipImpl(tooltip, options) {
        var tooltipCss = {
            "left": options.left + "px",
            "top": options.top + "px"
        },
            actalOpacity = tooltip.attr("data-opacity") || 0,
            zindex = tooltip.css("z-index");

        if (parseInt(zindex, 10) === 0
            || zindex === "auto") {
            tooltipCss["z-index"] = 9999;
        }

        tooltip.css(tooltipCss)
            .addClass('mapster_tooltip');


        if (options.fadeDuration && options.fadeDuration > 0) {
            u.fader(tooltip[0], 0, actalOpacity, options.fadeDuration);
        } else {
            u.setOpacity(tooltip[0], actalOpacity);
        }
    }

    /**
     * Hide and remove active tooltips
     *
     * @param  {MapData} this The mapdata object to which the tooltips belong
     */

    m.MapData.prototype.clearToolTip = function () {
        if (this.activeToolTip) {
            this.activeToolTip.stop().remove();
            this.activeToolTip = null;
            this.activeToolTipID = null;
            u.ifFunction(this.options.onHideToolTip, this);
        }
    };

    /**
     * Configure the binding between a named tooltip closing option, and a mouse event.
     *
     * If a callback is passed, it will be called when the activating event occurs, and the tooltip will
     * only closed if it returns true.
     *
     * @param  {MapData}  [this]     The MapData object to which this tooltip belongs.
     * @param  {String}   option     The name of the tooltip closing option
     * @param  {String}   event      UI event to bind to this option
     * @param  {Element}  target     The DOM element that is the target of the event
     * @param  {Function} [beforeClose] Callback when the tooltip is closed
     * @param  {Function} [onClose]  Callback when the tooltip is closed
     */
    function bindToolTipClose(options, bindOption, event, target, beforeClose, onClose) {
        var event_name = event + '.mapster-tooltip';

        if ($.inArray(bindOption, options) >= 0) {
            target.unbind(event_name)
                .bind(event_name, function (e) {
                    if (!beforeClose || beforeClose.call(this, e)) {
                        target.unbind('.mapster-tooltip');
                        if (onClose) {
                            onClose.call(this);
                        }
                    }
                });

            return {
                object: target,
                event: event_name
            };
        }
    }

    /**
     * Show a tooltip.
     *
     * @param {string|jquery}   [tooltip]       A string of html or a jQuery object containing the tooltip content.
     *
     * @param {string|jquery}   [target]        The target of the tooltip, to be used to determine positioning. If null,
     *                                          absolute position values must be passed with left and top.
     *
     * @param {string|jquery}   [image]         If target is an [area] the image that owns it
     *
     * @param {string|jquery}   [container]     An element within which the tooltip must be bounded
     *
     *
     *
     * @param {object|string|jQuery} [options]  options to apply when creating this tooltip - OR -
     *                                          The markup, or a jquery object, containing the data for the tooltip
     *
     *  @config {string}        [closeEvents]   A string with one or more comma-separated values that determine when the tooltip
     *                                          closes: 'area-click','tooltip-click','image-mouseout' are valid values
     *                                          then no template will be used.
     *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip
     *  @config {int}           [offsety]       the vertical amount to offset the tooltip
     *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip
     */

    function showToolTip(tooltip, target, image, container, options) {
        var corners,
            ttopts = {};

        options = options || {};


        if (target) {

            corners = u.areaCorners(target, image, container,
                                    tooltip.outerWidth(true),
                                    tooltip.outerHeight(true));

            // Try to upper-left align it first, if that doesn't work, change the parameters

            ttopts.left = corners[0];
            ttopts.top = corners[1];

        } else {

            ttopts.left = options.left;
            ttopts.top = options.top;
        }

        ttopts.left += (options.offsetx || 0);
        ttopts.top += (options.offsety || 0);

        ttopts.css = options.css;
        ttopts.fadeDuration = options.fadeDuration;

        showToolTipImpl(tooltip, ttopts);

        return tooltip;
    }

    /**
     * Show a tooltip positioned near this area.
      *
     * @param {string|jquery}   [content]       A string of html or a jQuery object containing the tooltip content.

     * @param {object|string|jQuery} [options]  options to apply when creating this tooltip - OR -
     *                                          The markup, or a jquery object, containing the data for the tooltip
     *  @config {string|jquery}   [container]     An element within which the tooltip must be bounded
     *  @config {bool}          [template]      a template to use instead of the default. If this property exists and is null,
     *                                          then no template will be used.
     *  @config {string}        [closeEvents]   A string with one or more comma-separated values that determine when the tooltip
     *                                          closes: 'area-click','tooltip-click','image-mouseout' are valid values
     *                                          then no template will be used.
     *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip
     *  @config {int}           [offsety]       the vertical amount to offset the tooltip
     *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip
     */
    m.AreaData.prototype.showToolTip = function (content, options) {
        var tooltip, closeOpts, target, tipClosed, template,
            ttopts = {},
            ad = this,
            md = ad.owner,
            areaOpts = ad.effectiveOptions();

        // copy the options object so we can update it
        options = options ? $.extend({}, options) : {};

        content = content || areaOpts.toolTip;
        closeOpts = options.closeEvents || areaOpts.toolTipClose || md.options.toolTipClose || 'tooltip-click';

        template = typeof options.template !== 'undefined' ?
                options.template :
                md.options.toolTipContainer;

        options.closeEvents = typeof closeOpts === 'string' ?
            closeOpts = u.split(closeOpts) :
            closeOpts;

        options.fadeDuration = options.fadeDuration ||
                 (md.options.toolTipFade ?
                    (md.options.fadeDuration || areaOpts.fadeDuration) : 0);

        target = ad.area ?
            ad.area :
            $.map(ad.areas(),
                function (e) {
                    return e.area;
                });

        if (md.activeToolTipID === ad.areaId) {
            return;
        }

        md.clearToolTip();

        md.activeToolTip = tooltip = createToolTip(content,
            template,
            options.css);

        md.activeToolTipID = ad.areaId;

        tipClosed = function () {
            md.clearToolTip();
        };

        bindToolTipClose(closeOpts, 'area-click', 'click', $(md.map), null, tipClosed);
        bindToolTipClose(closeOpts, 'tooltip-click', 'click', tooltip, null, tipClosed);
        bindToolTipClose(closeOpts, 'image-mouseout', 'mouseout', $(md.image), function (e) {
            return (e.relatedTarget && e.relatedTarget.nodeName !== 'AREA' && e.relatedTarget !== ad.area);
        }, tipClosed);


        showToolTip(tooltip,
                    target,
                    md.image,
                    options.container,
                    template,
                    options);

        u.ifFunction(md.options.onShowToolTip, ad.area,
        {
            toolTip: tooltip,
            options: ttopts,
            areaOptions: areaOpts,
            key: ad.key,
            selected: ad.isSelected()
        });

        return tooltip;
    };


    /**
     * Parse an object that could be a string, a jquery object, or an object with a "contents" property
     * containing html or a jQuery object.
     *
     * @param  {object|string|jQuery} options The parameter to parse
     * @return {string|jquery} A string or jquery object
     */
    function getHtmlFromOptions(options) {

        // see if any html was passed as either the options object itself, or the content property

        return (options ?
            ((typeof options === 'string' || options.jquery) ?
            options :
                options.content) :
            null);
    }

    /**
     * Activate or remove a tooltip for an area. When this method is called on an area, the
     * key parameter doesn't apply and "options" is the first parameter.
     *
     * When called with no parameters, or "key" is a falsy value, any active tooltip is cleared.
     *
     * When only a key is provided, the default tooltip for the area is used.
     *
     * When html is provided, this is used instead of the default tooltip.
     *
     * When "noTemplate" is true, the default tooltip template will not be used either, meaning only
     * the actual html passed will be used.
     *
     * @param  {string|AreaElement} key The area for which to activate a tooltip, or a DOM element.
     *
     * @param {object|string|jquery} [options] options to apply when creating this tooltip - OR -
     *                                         The markup, or a jquery object, containing the data for the tooltip
     *  @config {string|jQuery} [content]   the inner content of the tooltip; the tooltip text or HTML
     *  @config {Element|jQuery} [container]   the inner content of the tooltip; the tooltip text or HTML
     *  @config {bool}          [template]  a template to use instead of the default. If this property exists and is null,
     *                                      then no template will be used.
     *  @config {int}           [offsetx]   the horizontal amount to offset the tooltip.
     *  @config {int}           [offsety]   the vertical amount to offset the tooltip.
     *  @config {string|object} [css]       CSS to apply to the outermost element of the tooltip
     *  @config {string|object} [css] CSS to apply to the outermost element of the tooltip
     *  @config {bool}          [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
     * @return {jQuery} The jQuery object
     */

    m.impl.tooltip = function (key, options) {
        return (new m.Method(this,
        function mapData() {
            var tooltip, target, md = this;
            if (!key) {
                md.clearToolTip();
            } else {
                target = $(key);
                if (md.activeToolTipID === target[0]) {
                    return;
                }
                md.clearToolTip();

                md.activeToolTip = tooltip = createToolTip(getHtmlFromOptions(options),
                            options.template || md.options.toolTipContainer,
                            options.css);
                md.activeToolTipID = target[0];

                bindToolTipClose(['tooltip-click'], 'tooltip-click', 'click', tooltip, null, function () {
                    md.clearToolTip();
                });

                md.activeToolTip = tooltip = showToolTip(tooltip,
                    target,
                    md.image,
                    options.container,
                    options);
            }
        },
        function areaData() {
            if ($.isPlainObject(key) && !options) {
                options = key;
            }

            this.showToolTip(getHtmlFromOptions(options), options);
        },
        {
            name: 'tooltip',
            args: arguments,
            key: key
        }
    )).go();
    };
}(jQuery));

// ----------------------------------------
// Lightbox
//
// @author DxF5H
// @version 1.0.5
// @url https://github.com/DxF5H/lightbox
//
// MIT License
// ----------------------------------------

// Universal Module Definition
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else if (typeof module === "object" && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.lightbox = factory();
  }
}(this, function () {
  var lightbox = function (selector, userOptions) {
    "use strict";


    // -----------------
    // Default options
    // -----------------

    var options = {
      // Display captions, if available.
      captions: true,

      // Set the element where the caption is. Set it to "self" for the a-tag itself
      captionsSelector: "self",

      // Get the caption from given attribute.
      captionAttribute: "title",

      // Display navigation buttons. "auto" hides buttons on touch-enabled devices.
      nav: "auto",

      // Text or HTML for the navigation buttons.
      navText: ["&lsaquo;", "&rsaquo;"],

      // Display close button.
      close: true,

      // Text or HTML for the close button.
      closeText: "&times;",

      // Display current image index
      counter: true,

      // Allow keyboard navigation.
      keyboard: true,

      // Display zoom icon.
      zoom: true,

      // Text or HTML for the zoom icon
      zoomText: "&plus;",

      // Closes the lightbox when clicking outside
      docClose: false,

      // Swipe up to close lightbox
      swipeClose: true,

      // Hide scrollbars if lightbox is displayed.
      scroll: false
    };


    // ------------------
    // Global variables
    // ------------------

    // Array with all images
    var gallery = [];

    // Cache array length
    var galleryLength = null;

    // Array with all slider elements
    var sliderElement = [];

    // Current index
    var currentIndex = 0;

    // Object with touch positions
    var touch = {};

    // If set to true ignore touch events because animation was already fired
    var touchFlag = false;

    // The last focused element before opening the overlay
    var lastFocus = null;


    // --------------------------
    // Create lightbox components
    // --------------------------

    var overlay = document.createElement("div");
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-hidden", "true");
    overlay.classList.add("lightbox-overlay");
    document.getElementsByTagName("body")[0].appendChild(overlay);


    var slider = document.createElement("div");
    slider.classList.add("lightbox-slider");
    overlay.appendChild(slider);


    var prevButton = document.createElement("button");
    prevButton.setAttribute("type", "button");
    prevButton.setAttribute("aria-label", "Previous");
    overlay.appendChild(prevButton);


    var nextButton = document.createElement("button");
    nextButton.setAttribute("type", "button");
    nextButton.setAttribute("aria-label", "Next");
    overlay.appendChild(nextButton);


    var closeButton = document.createElement("button");
    closeButton.setAttribute("type", "button");
    closeButton.setAttribute("aria-label", "Close");
    overlay.appendChild(closeButton);


    var counter = document.createElement("div");
    counter.classList.add("lightbox-counter");
    overlay.appendChild(counter);


    // ------------------
    // Global functions
    // ------------------

    var mergeOptions = function (userOptions, options) {
      Object.keys(userOptions).forEach(function (key) {
        options[key] = userOptions[key];
      });
    };


    var loadImage = function (index, callback) {
      if (typeof gallery[index] === "undefined" || typeof sliderElement[index] === "undefined") {
        return;

        // If image is already loaded run callback and return
      } else if (!sliderElement[index].getElementsByTagName("img")[0].hasAttribute("data-src")) {
        if (callback) {
          callback();
        }
        return;
      }

      var figure = sliderElement[index].getElementsByTagName("figure")[0],
          image = figure.getElementsByTagName("img")[0],
          figcaption = figure.getElementsByTagName("figcaption")[0];

      image.onload = function () {
        var loader = figure.querySelector(".lightbox-loader");
        figure.removeChild(loader);
        image.style.opacity = "1";
        if (figcaption) {
          figcaption.style.opacity = "1";
        }
      };

      image.setAttribute("src", image.getAttribute("data-src"));
      image.removeAttribute("data-src");

      // Run callback
      if (callback) {
        callback();
      }
    };


    var transformSupport = function () {
      var div = document.documentElement.style;

      if (typeof div.transform == "string") {
        return true;
      }
      return false;
    };


    var updateOffset = function () {
      var offset = -currentIndex * 100 + "%";

      if (transformSupport()) {
        slider.style.transform = "translate(" + offset + ", 0)";
      } else {
        slider.style.left = offset;
      }
    };


    var updateCounter = function () {
      counter.innerHTML = (currentIndex + 1) + "/" + galleryLength;
    };


    var updateFocus = function (direction) {
      prevButton.disabled = false;
      nextButton.disabled = false;

      if (currentIndex === galleryLength - 1) {
        prevButton.disabled = false;
        nextButton.disabled = true;
      } else if (currentIndex === 0) {
        prevButton.disabled = true;
        nextButton.disabled = false;
      }

      if (options.nav) {
        if (!nextButton.disabled && direction !== "left") {
          nextButton.focus();
        } else {
          prevButton.focus();
        }
      } else if (options.close) {
        closeButton.focus();
      }
    };


    var preloadImage = function (index) {
      loadImage(index);
    };


    var nextImage = function () {
      // If next image exists
      if (currentIndex < galleryLength - 1) {
        currentIndex++;

        // Updates
        updateOffset();
        updateCounter();
        updateFocus();

        preloadImage(currentIndex + 1);
      }
    };


    var prevImage = function () {
      // If previous image exists
      if (currentIndex > 0) {
        currentIndex--;

        // Updates
        updateOffset();
        updateCounter();
        updateFocus();

        preloadImage(currentIndex - 1);
      }
    };


    var createOverlay = function () {
      var i = 0,
          x = 0,
          figureWrapper = null,
          figure = null,
          figuresIds = [],
          figcaption = null,
          figcaptionsIds = [];

      for (; i < galleryLength; ++i) {
        sliderElement[i] = document.createElement("div");
        sliderElement[i].classList.add("lightbox-content");
        sliderElement[i].id = "lightbox-content-" + i;

        // Create figure wrapper
        figureWrapper = document.createElement("div");
        figureWrapper.classList.add("lightbox-figure-wrapper");
        figureWrapper.id = "lightbox-figure-wrapper-" + i;

        // Create figure
        figure = document.createElement("figure");
        figure.innerHTML = "<div class=\"lightbox-loader\"></div>";

        // Create image
        var image = document.createElement("img");
        image.style.opacity = "0";

        if (gallery[i].selector.getElementsByTagName("img")[0] && gallery[i].selector.getElementsByTagName("img")[0].alt) {
          image.alt = gallery[i].selector.getElementsByTagName("img")[0].alt;
        } else {
          image.alt = "";
        }
        image.setAttribute("src", "");
        image.setAttribute("data-src", gallery[i].selector.href);

        // Add image to figure
        figure.appendChild(image);

        // Create figcaption
        if (options.captions) {
          figcaption = document.createElement("figcaption");
          figcaption.style.opacity = "0";

          if (options.captionsSelector == "self" && gallery[i].selector.getAttribute(options.captionAttribute)) {
            figcaption.innerHTML = gallery[i].selector.getAttribute(options.captionAttribute);
          } else if (options.captionsSelector == "img" && gallery[i].selector.getElementsByTagName("img")[0].getAttribute(options.captionAttribute)) {
            figcaption.innerHTML = gallery[i].selector.getElementsByTagName("img")[0].getAttribute(options.captionAttribute);
          }

          if (figcaption.innerHTML) {
            figure.id = "lightbox-figure-" + x;
            figcaption.id = "lightbox-figcaption-" + x;
            figure.appendChild(figcaption);

            figuresIds.push("lightbox-figure-" + x);
            figcaptionsIds.push("lightbox-figcaption-" + x);
            ++x;
          }
        }

        // Add figure to figure wrapper
        figureWrapper.appendChild(figure);

        // Add figure wrapper to slider element
        sliderElement[i].appendChild(figureWrapper);

        // Add slider element to slider
        slider.appendChild(sliderElement[i]);
      }

      if (x !== 0) {
        overlay.setAttribute("aria-labelledby", figuresIds.join(" "));
        overlay.setAttribute("aria-describedby", figcaptionsIds.join(" "));
      }

      // Hide buttons if necessary
      if (!options.nav || galleryLength === 1 || (options.nav === "auto" && "ontouchstart" in window)) {
        prevButton.style.display = "none";
        nextButton.style.display = "none";
      } else {
        prevButton.innerHTML = options.navText[0];
        nextButton.innerHTML = options.navText[1];
      }

      // Hide counter if necessary
      if (!options.counter || galleryLength === 1) {
        counter.style.display = "none";
      }

      // Hide close if necessary
      if (!options.close) {
        closeButton.style.display = "none";
      } else {
        closeButton.innerHTML = options.closeText;
      }
    };


    var openOverlay = function (index) {
      if (overlay.getAttribute("aria-hidden") === "false") {
        return;
      }

      if (!options.scroll) {
        document.documentElement.classList.add("lightbox-no-scroll");
        document.body.classList.add("lightbox-no-scroll");
      }

      // Save last focused element
      lastFocus = document.activeElement;

      // Set current index
      currentIndex = index;

      // Reset touch positions
      touch = {
        count: 0,
        startX: null,
        startY: null,
        moveX: null,
        moveY: null,
      };

      // Bind events
      bindEvents();

      // load image
      loadImage(currentIndex, function () {
        preloadImage(currentIndex + 1);
        preloadImage(currentIndex - 1);
      });

      updateOffset();
      updateCounter();
      overlay.setAttribute("aria-hidden", "false");

      updateFocus();
    };


    var closeOverlay = function () {
      if (overlay.getAttribute("aria-hidden") === "true") {
        return;
      }

      if (!options.scroll) {
        document.documentElement.classList.remove("lightbox-no-scroll");
        document.body.classList.remove("lightbox-no-scroll");
      }

      // Unbind events
      unbindEvents();

      overlay.setAttribute("aria-hidden", "true");

      // Focus
      lastFocus.focus();
    };


    // ------------------
    // Event handler
    // ------------------

    var clickHandler = function (event) {
      if (this === prevButton) {
        prevImage();
        updateFocus("left");
      } else if (this === nextButton) {
        nextImage();
        updateFocus("right");
      } else if (this === closeButton || this === overlay && event.target.id.indexOf("lightbox-figure-wrapper") !== -1) {
        closeOverlay();
      }

      event.preventDefault();
    };


    var keyupHandler = function (event) {
      switch (event.keyCode) {
        // Left arrow
        case 37:
          prevImage();
          updateFocus("left");
          break;

        // Right arrow
        case 39:
          nextImage();
          updateFocus("right");
          break;

        // Esc
        case 27:
          closeOverlay();
          break;
      }
    };


    var touchstartHandler = function (event) {
      touch.count++;
      if (touch.count > 1) {
        touch.multitouch = true;
      }
      // Get the touch position
      touch.startX = event.changedTouches[0].pageX;
      touch.startY = event.changedTouches[0].pageY;
    };

    var touchmoveHandler = function (event) {
      // If action was already triggered or multitouch return
      if (touchFlag || touch.multitouch) {
        return;
      }

      touch.moveX = event.changedTouches[0].pageX;
      touch.moveY = event.changedTouches[0].pageY;

      // Move > 50 pixels left or right to navigate
      if (touch.moveX - touch.startX > 50) {
        touchFlag = true;
        prevImage();
      } else if (touch.moveX - touch.startX < -50) {
        touchFlag = true;
        nextImage();

        // Move > 100 pixels up to close the overlay
      } else if (options.swipeClose && touch.startY - touch.moveY > 100) {
        closeOverlay();
      }

      event.preventDefault();
    };


    var touchendHandler = function () {
      touch.count--;
      if (touch.count <= 0) {
        touch.multitouch = false;
      }
      touchFlag = false;
    };


    var trapFocus = function (event) {
      if (overlay.getAttribute("aria-hidden") === "false" && !overlay.contains(event.target)) {
        event.stopPropagation();
        updateFocus();
      }
    };


    var bindEvents = function () {
      if (options.keyboard) {
        document.addEventListener("keyup", keyupHandler, false);
      }

      if (options.docClose) {
        overlay.addEventListener("click", clickHandler, false);
      }

      prevButton.addEventListener("click", clickHandler, false);
      nextButton.addEventListener("click", clickHandler, false);
      closeButton.addEventListener("click", clickHandler, false);
      overlay.addEventListener("touchstart", touchstartHandler, false);
      overlay.addEventListener("touchmove", touchmoveHandler, false);
      overlay.addEventListener("touchend", touchendHandler, false);
      document.addEventListener("focus", trapFocus, true);
    };


    var unbindEvents = function () {
      if (options.keyboard) {
        document.removeEventListener("keyup", keyupHandler, false);
      }

      if (options.docClose) {
        overlay.removeEventListener("click", clickHandler, false);
      }

      prevButton.removeEventListener("click", clickHandler, false);
      nextButton.removeEventListener("click", clickHandler, false);
      closeButton.removeEventListener("click", clickHandler, false);
      overlay.removeEventListener("touchstart", touchstartHandler, false);
      overlay.removeEventListener("touchmove", touchmoveHandler, false);
      overlay.removeEventListener("touchend", touchendHandler, false);
      document.removeEventListener("focus", trapFocus, true);
    };


    // ------
    // Setup
    // ------

    var setup = function (selector, userOptions) {
      // Merge user options into defaults
      if (userOptions) {
        mergeOptions(userOptions, options);
      }

      // Get a list of all elements within the document
      var elements = document.querySelectorAll(selector);

      if (!elements.length) {
        throw new Error("Ups, I can't find the selector \"" + selector + "\".");
      }

      // Execute a few things once per element
      [].forEach.call(elements, function(element, index) {
        // Set zoom icon if necessary
        if (options.zoom && element.getElementsByTagName("img")[0]) {
          var lightboxZoom = document.createElement("div");

          lightboxZoom.classList.add("lightbox-zoom-icon");
          lightboxZoom.innerHTML = options.zoomText;

          element.classList.add("lightbox-zoom");
          element.appendChild(lightboxZoom);
        }

        // Bind event
        element.addEventListener("click", function (event) {
          openOverlay(index);

          event.preventDefault();
        }, true);

        // Add element to gallery
        gallery.push({
          selector: element
        });
      });

      galleryLength = gallery.length;
      createOverlay();
    };


    setup(selector, userOptions);
  };

  return lightbox;
}));
if ($(window).width() >= 1200) {
    $(window).bind('mousewheel DOMMouseScroll MozMousePixelScroll', function (event) {
        if (!$(this).scrollTop()) {
            $('body').removeClass('fixed-header');
        }
        delta = parseInt(event.originalEvent.wheelDelta || -event.originalEvent.detail);
        if (delta >= 0) {
            $('.slide_animated ').removeClass('active');
        } else {
            $('body ').addClass('fixed-header');
        }
    });

    $('.slide_animated').on('DOMMouseScroll mousewheel', function (ev) {
        $('body').addClass('fixed-header');
        $(this).addClass('active');
        var $this = $(this),
            scrollTop = this.scrollTop,
            scrollHeight = this.scrollHeight,
            height = $this.height(),
            delta = (ev.type == 'DOMMouseScroll' ?
            ev.originalEvent.detail * -40 :
                ev.originalEvent.wheelDelta),
            up = delta > 0;

        var prevent = function () {
            ev.stopPropagation();
            ev.preventDefault();
            ev.returnValue = false;
            return false;
        };

        if (!up && -delta > scrollHeight - height - scrollTop) {
// Scrolling down, but this will take us past the bottom.
            $this.scrollTop(scrollHeight);
            return prevent();
        } else if (up && delta > scrollTop) {
// Scrolling up, but this will take us past the top.
            return prevent();

        }
    });

    $(window).scroll(function () {
        if ($(this).scrollTop())
            $('body').addClass('fixed-header');

        var offset = 10;
        if ($(this).scrollTop() > offset) {
            $('.slide_animated').addClass('active');
        }
    });
}
/* scroll to top */
var offset = 300,
    offset_opacity = 1200,
    scroll_top_duration = 500,
    $back_to_top = $('.to-top');

$(window).scroll(function () {
    ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('is-visible') : $back_to_top.removeClass('is-visible fade-out');
    if ($(this).scrollTop() > offset_opacity) {
        $back_to_top.addClass('fade-out');
    }
});

$back_to_top.on('click', function (event) {
    event.preventDefault();
    $('body,html').animate({
            scrollTop: 0,
        }, scroll_top_duration
    );
});

/* Scroll Function */
$(window).scroll(function () {

    /* Fixed Navigation */
    if ($('header').offset().top > 0) {
        $('body').addClass('fixed-header');
    } else {
        $('body').removeClass('fixed-header');
        $('.slide_animated').removeClass('active');
    }
});


if ($(window).width() >= 992) {
    $('.dropdown-toggle').click(function () {
        $('.search-field').addClass('offtop');
    });
    $(document).on('click', function (e) {
        if (!$(e.target).closest('.dropdown-toggle.active').length) {
            $('.search-field').removeClass('offtop');
        }
        e.stopPropagation();
    });
}
if ($(window).width() <= 991) {
    /* news slider */
    $('.responsive').slick({
        dots: true,
        infinite: false,
        speed: 300,
        responsive: [
            {
                breakpoint: 768,
                settings: {
                    slidesToShow: 1,
                    slidesToScroll: 1,
                    infinite: true,
                    dots: true,
                    arrows: false
                }
            },
            {
                breakpoint: 480,
                settings: {
                    slidesToShow: 1,
                    slidesToScroll: 1,
                    infinite: true,
                    dots: true,
                    arrows: true
                }
            }
        ]
    });

    $('.photo-gallery').slick({
        dots: false,
        adaptiveHeight: true,
        infinite: false,
        speed: 300,
        responsive: [
            {
                breakpoint: 768,
                settings: {
                    slidesToShow: 1,
                    slidesToScroll: 1,
                    infinite: true,
                    arrows: true
                }
            },
            {
                breakpoint: 480,
                settings: {
                    slidesToShow: 1,
                    slidesToScroll: 1,
                    infinite: true,
                    dots: true,
                    arrows: true
                }
            }
        ]
    });
}
// var gmap = document.getElementById('map');
// var map;
// var settings = {
// 	home: {
// 		latitude: 55.708411,
// 		longitude: 37.658046
// 	},
// 	icon_url: '',
// 	zoom: 16
// };
//
// var coords = new google.maps.LatLng(settings.home.latitude, settings.home.longitude);
//
// var options = {
// 	zoom: settings.zoom,
// 	scrollwheel: false,
// 	center: coords,
// 	mapTypeId: google.maps.MapTypeId.ROADMAP,
// 	mapTypeControl: true,
// 	scaleControl: true,
// 	streetViewControl: false,
// 	zoomControlOptions: {
// 		style: google.maps.ZoomControlStyle.DEFAULT
// 	},
// 	overviewMapControl: true
// 	/*styles: [{
// 	 "featureType": "water",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#e9e9e9"
// 	 }, {
// 	 "lightness": 17
// 	 }]
// 	 }, {
// 	 "featureType": "landscape",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#f5f5f5"
// 	 }, {
// 	 "lightness": 20
// 	 }]
// 	 }, {
// 	 "featureType": "road.highway",
// 	 "elementType": "geometry.fill",
// 	 "stylers": [{
// 	 "color": "#ffffff"
// 	 }, {
// 	 "lightness": 17
// 	 }]
// 	 }, {
// 	 "featureType": "road.highway",
// 	 "elementType": "geometry.stroke",
// 	 "stylers": [{
// 	 "color": "#ffffff"
// 	 }, {
// 	 "lightness": 29
// 	 }, {
// 	 "weight": 0.2
// 	 }]
// 	 }, {
// 	 "featureType": "road.arterial",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#ffffff"
// 	 }, {
// 	 "lightness": 18
// 	 }]
// 	 }, {
// 	 "featureType": "road.local",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#ffffff"
// 	 }, {
// 	 "lightness": 16
// 	 }]
// 	 }, {
// 	 "featureType": "poi",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#f5f5f5"
// 	 }, {
// 	 "lightness": 21
// 	 }]
// 	 }, {
// 	 "featureType": "poi.park",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#dedede"
// 	 }, {
// 	 "lightness": 21
// 	 }]
// 	 }, {
// 	 "elementType": "labels.text.stroke",
// 	 "stylers": [{
// 	 "visibility": "on"
// 	 }, {
// 	 "color": "#ffffff"
// 	 }, {
// 	 "lightness": 16
// 	 }]
// 	 }, {
// 	 "elementType": "labels.text.fill",
// 	 "stylers": [{
// 	 "saturation": 36
// 	 }, {
// 	 "color": "#333333"
// 	 }, {
// 	 "lightness": 40
// 	 }]
// 	 }, {
// 	 "elementType": "labels.icon",
// 	 "stylers": [{
// 	 "visibility": "off"
// 	 }]
// 	 }, {
// 	 "featureType": "transit",
// 	 "elementType": "geometry",
// 	 "stylers": [{
// 	 "color": "#f2f2f2"
// 	 }, {
// 	 "lightness": 19
// 	 }]
// 	 }, {
// 	 "featureType": "administrative",
// 	 "elementType": "geometry.fill",
// 	 "stylers": [{
// 	 "color": "#fefefe"
// 	 }, {
// 	 "lightness": 20
// 	 }]
// 	 }, {
// 	 "featureType": "administrative",
// 	 "elementType": "geometry.stroke",
// 	 "stylers": [{
// 	 "color": "#fefefe"
// 	 }, {
// 	 "lightness": 17
// 	 }, {
// 	 "weight": 1.2
// 	 }]
// 	 }]*/
// };
//
// map = new google.maps.Map(gmap, options);
//
// var end = new google.maps.Marker({
// 	position: new google.maps.LatLng(55.712169, 37.657553),
// 	map: map,
// 	icon: {
// 		url: 'http://www.supah.it/dribbble/020/end.png?v=3',
// 		origin: new google.maps.Point(0, 0)
// 	},
// 	draggable: false
// });
//
// var start = new google.maps.Marker({
// 	position: new google.maps.LatLng(55.70843, 37.6576228),
// 	map: map,
// 	icon: {
// 		url: 'http://www.supah.it/dribbble/020/start.png?v=3',
// 		origin: new google.maps.Point(0, 0)
// 	},
// 	draggable: false
// });
//
// var info = new google.maps.InfoWindow({
// 	content: settings.text
// });
//
// var runningCoords = [{
// 	lat: 55.7084648,
// 	lng: 37.6581888
// }, {
// 	lat: 55.708562,
// 	lng: 37.658243
// }, {
// 	lat: 55.708609,
// 	lng: 37.658205
// }, {
// 	lat: 55.708665,
// 	lng: 37.658198
// }, {
// 	lat: 55.708657,
// 	lng: 37.658200
// }, {
// 	lat: 55.708714,
// 	lng: 37.658203
// }, {
// 	lat: 55.708759,
// 	lng: 37.658203
// }, {
// 	lat: 55.708815,
// 	lng: 37.658207
// },{
// 	lat: 55.708866,
// 	lng: 37.658207
// },{
// 	lat: 55.708920,
// 	lng: 37.658215
// },{
// 	lat: 55.708866,
// 	lng: 37.658215
// },{
// 	lat: 55.708866,
// 	lng: 37.658207
// }, {
// 	lat: 55.712330,
// 	lng: 37.658236
// }, {
// 	lat: 55.712337,
// 	lng: 37.658186
// }, {
// 	lat: 55.712169,
// 	lng: 37.657553
// }];
//
// /* No Animation */
// /*
//  var runPath = new google.maps.Polyline({
//  path: runningCoords,
//  geodesic: true,
//  strokeColor: '#58a7e2',
//  strokeOpacity: 1.0,
//  strokeWeight: 3
//  });
//  runPath.setMap(map);
//  */
//
// /* Animation */
// var i = 0;
//
// function animPath() {
//
// 	if (i > runningCoords.lenght) {
// 		return false;
// 	}
//
// 	dept_lat = runningCoords[i].lat;
// 	dept_lng = runningCoords[i].lng;
// 	arr_lat = runningCoords[i + 1].lat;
// 	arr_lng = runningCoords[i + 1].lng;
//
// 	var departure = new google.maps.LatLng(dept_lat, dept_lng); //Set to whatever lat/lng you need for your departure location
// 	var arrival = new google.maps.LatLng(arr_lat, arr_lng); //Set to whatever lat/lng you need for your arrival location
// 	var line = new google.maps.Polyline({
// 		path: [departure, departure],
// 		strokeColor: "#572642",
// 		strokeOpacity: 1,
// 		strokeWeight: 3,
// 		geodesic: true, //set to false if you want straight line instead of arc
// 		map: map,
// 	});
// 	var step = 0;
// 	var numSteps = 25; //Change this to set animation resolution
// 	var timePerStep = 5; //Change this to alter animation speed
// 	var interval = setInterval(function () {
// 		step += 1;
// 		if (step > numSteps) {
// 			clearInterval(interval);
// 			i++;
// 			animPath();
// 		} else {
// 			var are_we_there_yet = google.maps.geometry.spherical.interpolate(departure, arrival, step / numSteps);
// 			line.setPath([departure, are_we_there_yet]);
// 		}
// 	}, timePerStep);
// }
//
// google.maps.event.addListenerOnce(map, 'idle', function () {
// 	setTimeout(init, 300);
// });
//
// function init() {
// 	animPath();
// 	/* Number animation */
// 	$('.info-box mark span').each(function () {
// 		$(this).prop('Counter', 0).animate({
// 			Counter: parseFloat($(this).text()).toFixed(1)
// 		}, {
// 			duration: 3000,
// 			easing: 'easeInOutQuart',
// 			step: function (now) {
// 				$(this).text(Math.round(now * 10) / 10);
// 			}
// 		});
// 	});
// }

/*
/!**
 * Add META tags (description, keywords, author) to page.
 *!/
var addMetaTags = function(text){
	//
	var meta = document.createElement('meta');
	meta.name = 'description';
	meta.content = text + '. ' +
		'Карта-Навигатор с проекциями Proj4js. ' +
		'HTML5 Canvas+SVG vector map with some Proj4js projections. ' +
		'Pure javascript and serverless';
	document.getElementsByTagName('head')[0].appendChild(meta);
	//
	var meta = document.createElement('meta');
	meta.name = 'keywords';
	meta.content = text + ', ' +
		'карта, html5, canvas, svg, 2d, vector, proj4js, projection, javascript, dbcartajs, map';
	document.getElementsByTagName('head')[0].appendChild(meta);
	//
	var meta = document.createElement('meta');
	meta.name = 'author';
	meta.content = 'Grigoriy Eremin';
	document.getElementsByTagName('head')[0].appendChild(meta);
	//
	var meta = document.createElement('meta');
	meta.name = 'google-site-verification';
	meta.content = 'tDIIwt3nNSOeRwaSbOPKjWIuVvKvi6E7YCLV_WOnCqE';
	document.getElementsByTagName('head')[0].appendChild(meta);
	//
	var meta = document.createElement('meta');
	meta.name = 'yandex-verification';
	meta.content = '494e5b88af1227b8';
	document.getElementsByTagName('head')[0].appendChild(meta);
};
/!**
 * Add Google Analytics counter.
 *!/
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-25857345-3', 'dbcartajs.appspot.com');
ga('send', 'pageview');
$('#slider0').slider();
/!**
 * List with coords of Moscow Metro lines and stations
 *  [[ftype, ftag, coords, label, centerof, ismap],...]
 * Three points with coords and 'Q' literal implements to bezierCurveTo (...) method.
 * egax@bk.ru, 2013-16.
 *!/
var MLINES = [
	['moskva_canal', 'mc', [
		[-120, 29],
		[-118, 32, 'Q'], [-118, 35, 'Q'], [-118, 39, 'Q'],
		[-115, 60, 'Q'], [-115, 64, 'Q'], [-113, 67, 'Q'],
		[-99, 80, 'Q'], [-97, 83, 'Q'], [-97, 86, 'Q'],
		[-97, 152]
	]
	],
	['strogino_lake_exit', 'sle', [
		[-138, 65],
		[-130, 71, 'Q'], [-127, 74, 'Q'], [-124, 74, 'Q'],
		[-119, 74, 'Q'], [-117, 74, 'Q'], [-117, 71.5, 'Q'],
		[-117, 71.5, 'Q'], [-117, 68.5, 'Q'], [-119, 68.5, 'Q'],
		[-131, 68.5],
		[-138, 65]
	]
	],
	['vodootvodny_canal', 'vc', [
		[-30, -40],
		[-27, -40, 'Q'], [-24, -40, 'Q'], [-21, -38, 'Q'],
		[-13, -30, 'Q'], [-9, -27, 'Q'], [-7, -27, 'Q'],
		[18, -27, 'Q'], [24, -27, 'Q'], [27, -31, 'Q'],
		[55, -59]
	]
	],
	['yauza_river', 'yr', [
		[31, -27],
		[65, -27, 'Q'], [77, -27, 'Q'], [77, -15, 'Q'],
		[77, 30, 'Q'], [77, 34, 'Q'], [80, 34, 'Q'],
		[80, 34, 'Q'], [83, 34, 'Q'], [83, 38, 'Q'],
		[83, 71, 'Q'], [83, 76, 'Q'], [79, 80, 'Q'],
		[59, 99, 'Q'], [55, 103, 'Q'], [50, 103, 'Q'],
		[42, 103, 'Q'], [32, 103, 'Q'], [32, 113, 'Q'],
		[32, 114, 'Q'], [32, 121, 'Q'], [39, 127, 'Q'],
		[63, 147]
	]
	],
	['Nagatino_poyma', 'np', [
		[58, -108],
		[66.8, -100.3, 'Q'], [69, -98, 'Q'], [71.5, -98, 'Q'],
		[72.5, -98, 'Q'], [74.7, -98, 'Q'], [77, -100, 'Q'],
		[83, -106, 'Q'], [85, -108, 'Q'], [85, -116, 'Q']
	]
	],
	['grebnoy_canal', 'gc', [
		[-138, 51], [-127, 53], [-122, 53], [-132, 51], [-138, 51]
	]
	],
	['moskva_river', 'mr', [
		[-175, 78],
		[-119, 78, 'Q'], [-110, 78, 'Q'], [-110, 71.5, 'Q'],
		[-110, 71.5, 'Q'], [-110, 65, 'Q'], [-119, 65, 'Q'],
		[-135, 65, 'Q'], [-144, 65, 'Q'], [-144, 61, 'Q'],
		[-144, 61, 'Q'], [-144, 57, 'Q'], [-135, 57, 'Q'],
		[-116, 57, 'Q'], [-113, 57, 'Q'], [-113, 52, 'Q'],
		[-113, 52, 'Q'], [-113, 47, 'Q'], [-116, 47, 'Q'],
		[-144, 47, 'Q'], [-150, 47, 'Q'], [-150, 39.5, 'Q'],
		[-150, 39.5, 'Q'], [-150, 32, 'Q'], [-144, 32, 'Q'],
		[-129, 32, 'Q'], [-120, 32, 'Q'], [-120, 28, 'Q'], //
		[-120, 12, 'Q'], [-120, 8, 'Q'], [-116, 6, 'Q'],
		[-67, 6, 'Q'], [-59, 6, 'Q'], [-59, -2, 'Q'],
		[-59, -31, 'Q'], [-59, -38, 'Q'], [-63, -41, 'Q'],
		[-96, -73, 'Q'], [-109, -85, 'Q'], [-98, -93, 'Q'],
		[-98, -93, 'Q'], [-90, -99, 'Q'], [-81, -90, 'Q'],
		[-14, -24, 'Q'], [-10, -20, 'Q'], [-5, -20, 'Q'],
		[19, -20, 'Q'], [25, -20, 'Q'], [28, -24, 'Q'],
		[52, -47, 'Q'], [55, -51, 'Q'], [55, -57, 'Q'],
		[55, -105, 'Q'], [55, -109, 'Q'], [65, -109, 'Q'],
		[79, -109, 'Q'], [85, -109, 'Q'], [85, -115, 'Q'],
		[85, -115, 'Q'], [85, -117, 'Q'], [80, -120.5, 'Q'],
		[80, -120.5, 'Q'], [74, -124, 'Q'], [74, -130, 'Q'],
		[74, -131, 'Q'], [74, -141, 'Q'], [84, -141, 'Q'],
		[102, -141, 'Q'], [106, -141, 'Q'], [111, -147, 'Q'],
		[233, -272]
	]
	],
//
	['sheremetyevo_express_line', 'sheremetyevo_express', [
		[-51, 55],
		[-23, 83, 'Q'], [-20, 86, 'Q'], [-20, 90, 'Q'],
		[-20, 149, 'Q'], [-20, 153, 'Q'], [-23, 153, 'Q'],
		[-29, 153]
	]
	],
	['sheremetyevo_express_line_d', 'sheremetyevo_express', [
		[-51, 55],
		[-23, 83, 'Q'], [-20, 86, 'Q'], [-20, 90, 'Q'],
		[-20, 149, 'Q'], [-20, 153, 'Q'], [-23, 153, 'Q'],
		[-29, 153]
	]
	],
	['vnukovo_express_line', 'vnukovo_express', [
		[-75, -20],
		[-94, -20, 'Q'], [-99, -20, 'Q'], [-103, -25, 'Q'],
		[-132, -65],
		[-163, -96, 'Q'], [-166, -99, 'Q'], [-166, -102, 'Q'],
		[-166, -119, 'Q'], [-166, -121, 'Q'], [-163, -121, 'Q'],
		[-160, -121]
	]
	],
	['vnukovo_express_line_d', 'vnukovo_express', [
		[-75, -20],
		[-94, -20, 'Q'], [-99, -20, 'Q'], [-103, -25, 'Q'],
		[-132, -65],
		[-163, -96, 'Q'], [-166, -99, 'Q'], [-166, -102, 'Q'],
		[-166, -119, 'Q'], [-166, -121, 'Q'], [-163, -121, 'Q'],
		[-160, -121]
	]
	],
	['domodedovo_express_line', 'domodedovo_express', [
		[51, -61], [51, -179]
	]
	],
	['domodedovo_express_line_d', 'domodedovo_express', [
		[51, -61], [51, -179]
	]
	],
//
	['r1', 'r1', [
		[102, 85],
		[38, 21, 'Q'], [36, 19, 'Q'], [34, 19, 'Q'],
		[20, 19, 'Q'], [17, 19, 'Q'], [14, 17, 'Q'],
		[-100, -97], [-115.9, -113.59],
		[-108.05, -105.4], [-123, -121], [-141, -140]
	]
	],
	['r1_ext', 'r1', []
	],
	['r2', 'r2', [
		[-92, 107, 'Q'], [-92, 102, 'Q'], [-90, 100, 'Q'],
		[-34, 45, 'Q'], [-31, 42, 'Q'], [-31, 38, 'Q'],
		[-31, 31, 'Q'], [-31, 27, 'Q'], [-29, 24, 'Q'],
		[20, -25, 'Q'], [23, -27, 'Q'], [23, -31, 'Q'],
		[23, -33, 'Q'], [23, -37, 'Q'], [26, -39, 'Q'],
		[65, -78, 'Q'], [68, -81, 'Q'], [68, -85, 'Q'],
		[68, -143, 'Q'], [68, -146, 'Q'], [70, -149, 'Q'],
		[81, -160],
		[95, -160]
	]
	],
	['r2_ext', 'r2', [
		[-92, 122], [-92, 107]
	]
	],
	['r3', 'r3', [
		[-159, 98],
		[-159, 18, 'Q'], [-159, 15, 'Q'], [-156, 12, 'Q'],
		[-130, -14, 'Q'], [-128, -16, 'Q'], [-124, -16, 'Q'],
		[-36, -16, 'Q'], [-33, -16, 'Q'], [-30, -14, 'Q'],
		[-30, -14, 'Q'], [-26, -11, 'Q'], [-24, -11, 'Q'],
		[53, -11, 'Q'], [57, -11, 'Q'], [59, -9, 'Q'],
		[137, 69]
	]
	],
	['r4', 'r4_1', [
		[-159, 34],
		[-131, 6, 'Q'], [-128, 3, 'Q'], [-124, 3, 'Q'],
		[-104, 3, 'Q'], [-101, 3, 'Q'], [-97, 0, 'Q'],
		[-93, -3, 'Q'], [-89, -6, 'Q'], [-87, -6, 'Q'],
		[-72, -6, 'Q'], [-68, -2, 'Q'], [-64, -2, 'Q'],
		[-26, -2, 'Q'], [-23, -2, 'Q'], [-20, -5, 'Q'],
		[-19, -6]
	]
	],
	['r4', 'r4_2', [
		[-72, -6],
		[-112, 21]
	]
	],
	['r5', 'r5', [
		[-70, 0], [-69.86, 4.40], [-69.45, 8.77], [-68.76, 13.12], [-67.80, 17.41], [-66.57, 21.63], [-65.08, 25.77], [-63.34, 29.80], [-61.34, 33.72], [-59.10, 37.51], [-56.63, 41.14], [-53.94, 44.62], [-51.03, 47.92], [-47.92, 51.03], [-44.62, 53.94], [-41.14, 56.63], [-37.51, 59.10], [-33.72, 61.34], [-29.80, 63.34], [-25.77, 65.08], [-21.63, 66.57], [-17.41, 67.80], [-13.12, 68.76], [-8.77, 69.45], [-4.40, 69.86], [0.00, 70.00], [4.40, 69.86], [8.77, 69.45], [13.12, 68.76], [17.41, 67.80], [21.63, 66.57], [25.77, 65.08], [29.80, 63.34], [33.72, 61.34], [37.51, 59.10], [41.14, 56.63], [44.62, 53.94], [47.92, 51.03], [51.03, 47.92], [53.94, 44.62], [56.63, 41.14], [59.10, 37.51], [61.34, 33.72], [63.34, 29.80], [65.08, 25.77], [66.57, 21.63], [67.80, 17.41], [68.76, 13.12], [69.45, 8.77], [69.86, 4.40], [70.00, 0.00], [69.86, -4.40], [69.45, -8.77], [68.76, -13.12], [67.80, -17.41], [66.57, -21.63], [65.08, -25.77], [63.34, -29.80], [61.34, -33.72], [59.10, -37.51], [56.63, -41.14], [53.94, -44.62], [51.03, -47.92], [47.92, -51.03], [44.62, -53.94], [41.14, -56.63], [37.51, -59.10], [33.72, -61.34], [29.80, -63.34], [25.77, -65.08], [21.63, -66.57], [17.41, -67.80], [13.12, -68.76], [8.77, -69.45], [4.40, -69.86], [0.00, -70.00], [-4.40, -69.86], [-8.77, -69.45], [-13.12, -68.76], [-17.41, -67.80], [-21.63, -66.57], [-25.77, -65.08], [-29.80, -63.34], [-33.72, -61.34], [-37.51, -59.10], [-41.14, -56.63], [-44.62, -53.94], [-47.92, -51.03], [-51.03, -47.92], [-53.94, -44.62], [-56.63, -41.14], [-59.10, -37.51], [-61.34, -33.72], [-63.34, -29.80], [-65.08, -25.77], [-66.57, -21.63], [-67.80, -17.41], [-68.76, -13.12], [-69.45, -8.77], [-69.86, -4.40], [-70, 0]
	], 'Radial'
	],
	['r6', 'r6', [
		[36, 129],
		[36, 38, 'Q'], [36, 35, 'Q'], [34, 32, 'Q'],
		[34, 32, 'Q'], [31, 28, 'Q'], [31, 26, 'Q'],
		[31, -22, 'Q'], [31, -26, 'Q'], [28, -29, 'Q'],
		[-41, -99, 'Q'], [-44, -102, 'Q'], [-44, -106, 'Q'],
		[-44, -168]
	]
	],
	['r6_ext', 'r6', [
		[36, 129], [36, 145]
	]
	],
	['r7', 'r7', [
		[-105, 99],
		[-105, 79, 'Q'], [-105, 75, 'Q'], [-103, 73, 'Q'],
		[-60, 31, 'Q'], [-58, 29, 'Q'], [-55, 29, 'Q'],
		[0, 29, 'Q'], [3, 29, 'Q'], [5, 27, 'Q'],
		[26, 6, 'Q'], [28, 4, 'Q'], [28, 0, 'Q'],
		[28, -10, 'Q'], [28, -14, 'Q'], [31, -16, 'Q'],
		[92, -77, 'Q'], [94.5, -80, 'Q'], [98, -80, 'Q'],
		[151, -80, 'Q'], [155, -80, 'Q'], [158, -84, 'Q'],
		[158, -84, 'Q'], [160, -87, 'Q'], [160, -90, 'Q'],
		[160, -90, 'Q'], [160, -93, 'Q'], [157, -96, 'Q'],
		[136, -117, 'Q'], [133, -120, 'Q'], [133, -124, 'Q'],
		[133, -126]
	]
	],
	['r8', 'r8', [
		[18, -39], [90, -39], [136, 6]
	]
	],
	['r8', 'r8_1', [
		[-97, 11],
		[-106, 11, 'Q'], [-109, 11, 'Q'], [-112, 8, 'Q'],
		[-117, 3, 'Q'], [-120, 0, 'Q'], [-120, -3, 'Q'],
		[-120, -16]
	]
	],
	['r8_ext', 'r8', [
		[18.15, -39],
		[-21, -39, 'Q'], [-24, -39, 'Q'], [-27, -37, 'Q'],
		[-74, 8, 'Q'], [-77, 11, 'Q'], [-80, 11, 'Q'],
		[-97, 11]
	]
	],
	['r8_ext', 'r8_1', [
		[-120, -16],
		[-120, -59, 'Q'], [-120, -62, 'Q'], [-123, -65, 'Q'],
		[-162, -105]
	]
	],
	['r9', 'r9', [
		[0, 146],
		[0, 137, 'Q'], [0, 134, 'Q'], [-2, 131, 'Q'],
		[-26, 107, 'Q'], [-29, 104, 'Q'], [-29, 101, 'Q'],
		[-29, 76, 'Q'], [-29, 73, 'Q'], [-26, 70, 'Q'],
		[-5, 48, 'Q'], [-4, 47, 'Q'], [-4, 46, 'Q'],
		[-4, 41, 'Q'], [-4, 40, 'Q'], [-5, 39, 'Q'],
		[-18, 25.06, 'Q'], [-19, 24, 'Q'], [-19, 21, 'Q'],
		[-19, -19, 'Q'], [-19, -22, 'Q'], [-16, -25, 'Q'],
		[16, -58, 'Q'], [19, -61, 'Q'], [19, -64, 'Q'],
		[19, -127, 'Q'], [19, -130, 'Q'], [16, -133, 'Q'],
		[-12, -168]
	]
	],
	['r10', 'r10', [
		[1, 87, 'Q'], [4, 85, 'Q'], [4, 81, 'Q'],
		[4, 45, 'Q'], [4, 41, 'Q'], [7, 38, 'Q'],
		[82, -36, 'Q'], [84, -38, 'Q'], [84, -42, 'Q'],
		[84, -72, 'Q'], [84, -74.5, 'Q'], [87, -78, 'Q'],
		[105, -96, 'Q'], [108, -99, 'Q'], [108, -103, 'Q'],
		[108, -106, 'Q'], [108, -109, 'Q'], [105, -112, 'Q'],
		[87, -130, 'Q'], [84, -133, 'Q'], [84, -137, 'Q'],
		[84, -163]
	]
	],
	['r10_ext', 'r10', [
		[1, 87],
		[-22, 112, 'Q'], [-24, 114, 'Q'], [-24, 118, 'Q'],
		[-24, 146]
	]
	],
	['r11', 'r11', [
		[20, -135],
		[62, -135, 'Q'], [68, -135, 'Q'], [68, -129, 'Q']
	]
	],
	['r12', 'r12', [
		[-16, -168],
		[-22, -176, 'Q'], [-24, -179, 'Q'], [-26, -179, 'Q'],
		[-87, -179]
	]
	],
	['r12_ext', 'r12_1', [
		[-87, -179], [-150, -179]
	]
	],
	['r12', 'r12_2', [
		[-41, -168], [-16, -168]
	]
	],
	['rTPK', 'rTPK_1', [
		[-112, -159], [-78, -118],
		[-78, -100, 'Q'], [-78, -98, 'Q'], [-80, -96, 'Q'],
		[-90, -87], [-90, 1],
		[-104, 11, 'Q'], [-116, 18, 'Q'], [-116, 20, 'Q'],
		[-116, 30, 'Q'], [-116, 32, 'Q'], [-112, 32, 'Q'],
		[-86, 32, 'Q'], [-80, 32, 'Q'], [-80, 36, 'Q'],
		[-80, 44],
		[-44, 80, 'Q'], [-42, 82, 'Q'], [-38, 82, 'Q'],
		[57, 82, 'Q'], [60, 82, 'Q'], [63, 80, 'Q'],
		[77, 65, 'Q'], [80, 62, 'Q'], [80, 59, 'Q'],
		[80, 19, 'Q'], [80, 15, 'Q'], [83, 13, 'Q'],
		[101, -4, 'Q'], [103, -7, 'Q'], [103, -11, 'Q'],
		[103, -24, 'Q'], [103, -27, 'Q'], [106, -30, 'Q'],
		[124, -48], [124, -53, 'Q'], [124, -55, 'Q'], [123, -56, 'Q'],
		[93, -92.46],
		[68, -129]
	]
	],
	['rTPK', 'rTPK_2', [
		[-80, 44],
		[-82, 42, 'Q'], [-84, 40, 'Q'], [-88, 40, 'Q'],
		[-143, 40, 'Q'], [-147, 40, 'Q'], [-149, 37, 'Q'],
		[-163, 23, 'Q'], [-166, 20, 'Q'], [-166, 17, 'Q'],
		[-166, -1, 'Q'], [-166, -5, 'Q'], [-164, -7, 'Q'],
		[-113, -58, 'Q'], [-110, -60, 'Q'], [-110, -64, 'Q'],
		[-110, -100.95],
		[-50, -133],
		[14.5, -133]
	]
	],
	['rKOZH', 'rKOZH', [
		[106, -30],
		[135, -59, 'Q'], [137, -61, 'Q'], [137, -65, 'Q'],
		[137, -82, 'Q'], [137, -85, 'Q'], [140, -88, 'Q'],
		[162, -112, 'Q'], [165, -115, 'Q'], [165, -118, 'Q'],
		[165, -138]
	]
	],
	['monorail', 'mn', [
		[-26, 101], [43, 101]
	]
	],
	['mck', 'mck', [
		[-117, 0], [-116.769127226108, 7.34649078492966], [-116.077420053794, 14.6639883270236], [-114.927608335257, 21.9236138065298], [-113.32422985205, 29.096716798288], [-111.273612406533, 36.1549883418688], [-108.783848848925, 43.0705726641073], [-105.864765138524, 49.8161771131135], [-102.527881565132, 56.3651798699007], [-98.7863672837358, 62.6917350125426], [-94.6549883418689, 68.7708745182194], [-90.1500494047673, 74.5786068005967], [-85.2893294083052, 80.0920113936566], [-80.0920113936566, 85.2893294083052], [-74.5786068005967, 90.1500494047673], [-68.7708745182193, 94.6549883418689], [-62.6917350125426, 98.7863672837358], [-56.3651798699007, 102.527881565132], [-49.8161771131135, 105.864765138524], [-43.0705726641073, 108.783848848925], [-36.1549883418689, 111.273612406533], [-29.096716798288, 113.32422985205], [-21.9236138065298, 114.927608335257], [-14.6639883270236, 116.077420053794], [-7.34649078492966, 116.769127226108], [1.88150350012166e-14, 117], [7.34649078492967, 116.769127226108], [14.6639883270236, 116.077420053794], [21.9236138065298, 114.927608335257], [29.096716798288, 113.32422985205], [36.1549883418689, 111.273612406533], [43.0705726641073, 108.783848848925], [49.8161771131135, 105.864765138524], [56.3651798699007, 102.527881565132], [62.6917350125426, 98.7863672837358], [68.7708745182193, 94.6549883418689], [74.5786068005967, 90.1500494047673], [80.0920113936566, 85.2893294083051], [85.2893294083052, 80.0920113936565], [90.1500494047674, 74.5786068005967], [94.6549883418688, 68.7708745182194], [98.7863672837358, 62.6917350125426], [102.527881565132, 56.3651798699007], [105.864765138524, 49.8161771131135], [108.783848848925, 43.0705726641073], [111.273612406533, 36.1549883418688], [113.32422985205, 29.096716798288], [114.927608335257, 21.9236138065298], [116.077420053794, 14.6639883270236], [116.769127226108, 7.34649078492964], [117, -3.76300700024333e-14], [116.769127226108, -7.34649078492966], [116.077420053794, -14.6639883270236], [114.927608335257, -21.9236138065298], [113.32422985205, -29.096716798288], [111.273612406533, -36.1549883418689], [108.783848848925, -43.0705726641074], [105.864765138524, -49.8161771131135], [102.527881565132, -56.3651798699007], [98.7863672837358, -62.6917350125426], [94.6549883418688, -68.7708745182194], [90.1500494047673, -74.5786068005967], [85.2893294083052, -80.0920113936566], [80.0920113936566, -85.2893294083052], [74.5786068005967, -90.1500494047674], [68.7708745182194, -94.6549883418688], [62.6917350125426, -98.7863672837358], [56.3651798699007, -102.527881565132], [49.8161771131134, -105.864765138524], [43.0705726641073, -108.783848848925], [36.1549883418689, -111.273612406533], [29.096716798288, -113.32422985205], [21.9236138065298, -114.927608335257], [14.6639883270235, -116.077420053794], [7.34649078492965, -116.769127226108], [2.1492551325036e-14, -117], [-7.34649078492971, -116.769127226108], [-14.6639883270236, -116.077420053794], [-21.9236138065298, -114.927608335257], [-29.096716798288, -113.32422985205], [-36.1549883418688, -111.273612406533], [-43.0705726641074, -108.783848848925], [-49.8161771131135, -105.864765138524], [-56.3651798699007, -102.527881565132], [-62.6917350125426, -98.7863672837358], [-68.7708745182194, -94.6549883418688], [-74.5786068005967, -90.1500494047673], [-80.0920113936566, -85.2893294083052], [-85.2893294083052, -80.0920113936565], [-90.1500494047674, -74.5786068005967], [-94.6549883418689, -68.7708745182193], [-98.7863672837358, -62.6917350125426], [-102.527881565132, -56.3651798699007], [-105.864765138524, -49.8161771131134], [-108.783848848925, -43.0705726641073], [-111.273612406533, -36.1549883418688], [-113.32422985205, -29.096716798288], [-114.927608335257, -21.9236138065298], [-116.077420053794, -14.6639883270235], [-116.769127226108, -7.34649078492965], [-117, 0]
	], 'MCK'
	],
	['mck_d', 'mck_d', [
		[-117, 0], [-116.769127226108, 7.34649078492966], [-116.077420053794, 14.6639883270236], [-114.927608335257, 21.9236138065298], [-113.32422985205, 29.096716798288], [-111.273612406533, 36.1549883418688], [-108.783848848925, 43.0705726641073], [-105.864765138524, 49.8161771131135], [-102.527881565132, 56.3651798699007], [-98.7863672837358, 62.6917350125426], [-94.6549883418689, 68.7708745182194], [-90.1500494047673, 74.5786068005967], [-85.2893294083052, 80.0920113936566], [-80.0920113936566, 85.2893294083052], [-74.5786068005967, 90.1500494047673], [-68.7708745182193, 94.6549883418689], [-62.6917350125426, 98.7863672837358], [-56.3651798699007, 102.527881565132], [-49.8161771131135, 105.864765138524], [-43.0705726641073, 108.783848848925], [-36.1549883418689, 111.273612406533], [-29.096716798288, 113.32422985205], [-21.9236138065298, 114.927608335257], [-14.6639883270236, 116.077420053794], [-7.34649078492966, 116.769127226108], [1.88150350012166e-14, 117], [7.34649078492967, 116.769127226108], [14.6639883270236, 116.077420053794], [21.9236138065298, 114.927608335257], [29.096716798288, 113.32422985205], [36.1549883418689, 111.273612406533], [43.0705726641073, 108.783848848925], [49.8161771131135, 105.864765138524], [56.3651798699007, 102.527881565132], [62.6917350125426, 98.7863672837358], [68.7708745182193, 94.6549883418689], [74.5786068005967, 90.1500494047673], [80.0920113936566, 85.2893294083051], [85.2893294083052, 80.0920113936565], [90.1500494047674, 74.5786068005967], [94.6549883418688, 68.7708745182194], [98.7863672837358, 62.6917350125426], [102.527881565132, 56.3651798699007], [105.864765138524, 49.8161771131135], [108.783848848925, 43.0705726641073], [111.273612406533, 36.1549883418688], [113.32422985205, 29.096716798288], [114.927608335257, 21.9236138065298], [116.077420053794, 14.6639883270236], [116.769127226108, 7.34649078492964], [117, -3.76300700024333e-14], [116.769127226108, -7.34649078492966], [116.077420053794, -14.6639883270236], [114.927608335257, -21.9236138065298], [113.32422985205, -29.096716798288], [111.273612406533, -36.1549883418689], [108.783848848925, -43.0705726641074], [105.864765138524, -49.8161771131135], [102.527881565132, -56.3651798699007], [98.7863672837358, -62.6917350125426], [94.6549883418688, -68.7708745182194], [90.1500494047673, -74.5786068005967], [85.2893294083052, -80.0920113936566], [80.0920113936566, -85.2893294083052], [74.5786068005967, -90.1500494047674], [68.7708745182194, -94.6549883418688], [62.6917350125426, -98.7863672837358], [56.3651798699007, -102.527881565132], [49.8161771131134, -105.864765138524], [43.0705726641073, -108.783848848925], [36.1549883418689, -111.273612406533], [29.096716798288, -113.32422985205], [21.9236138065298, -114.927608335257], [14.6639883270235, -116.077420053794], [7.34649078492965, -116.769127226108], [2.1492551325036e-14, -117], [-7.34649078492971, -116.769127226108], [-14.6639883270236, -116.077420053794], [-21.9236138065298, -114.927608335257], [-29.096716798288, -113.32422985205], [-36.1549883418688, -111.273612406533], [-43.0705726641074, -108.783848848925], [-49.8161771131135, -105.864765138524], [-56.3651798699007, -102.527881565132], [-62.6917350125426, -98.7863672837358], [-68.7708745182194, -94.6549883418688], [-74.5786068005967, -90.1500494047673], [-80.0920113936566, -85.2893294083052], [-85.2893294083052, -80.0920113936565], [-90.1500494047674, -74.5786068005967], [-94.6549883418689, -68.7708745182193], [-98.7863672837358, -62.6917350125426], [-102.527881565132, -56.3651798699007], [-105.864765138524, -49.8161771131134], [-108.783848848925, -43.0705726641073], [-111.273612406533, -36.1549883418688], [-113.32422985205, -29.096716798288], [-114.927608335257, -21.9236138065298], [-116.077420053794, -14.6639883270235], [-116.769127226108, -7.34649078492965], [-117, 0]
	], 'MCK'
	],
//
	['interchange', 'Kievskaya', [
		[-72, -16], [-72, -6], [-69.09, -11], [-72, -16]
	]
	],
	['interchange_d', 'Kievskaya', [
		[-72, -16], [-72, -6], [-69.09, -11], [-72, -16]
	]
	],
	['interchange', 'Rossyskaya-Kutuzovsky_Prospekt', [
		[-69.38, 9.24], [-69.38, 3.63]
	]
	],
	['interchange_d', 'Rossyskaya-Kutuzovsky_Prospekt', [
		[-69.38, 9.24], [-69.38, 3.63]
	]
	],
	['interchange', 'Krasnopresnenskaya-Barrikadnaya', [
		[-64.8, 26.41], [-60.34, 31.34]
	]
	],
	['interchange_d', 'Krasnopresnenskaya-Barrikadnaya', [
		[-64.8, 26.41], [-60.34, 31.34]
	]
	],
	['interchange', 'Belorusskaya', [
		[-47, 51.84], [-47, 57.78]
	]
	],
	['interchange_d', 'Belorusskaya', [
		[-47, 51.84], [-47, 57.78]
	]
	],
	['interchange', 'Mendeleyevskaya-Novoslobodskaya', [
		[-26, 65.36], [-26, 70]
	]
	],
	['interchange_d', 'Mendeleyevskaya-Novoslobodskaya', [
		[-26, 65.36], [-26, 70]
	]
	],
	['interchange', 'Dostoyevskaya-Suvorovskaya', [
		[4, 69.88], [4, 75]
	]
	],
	['interchange_d', 'Dostoyevskaya-Suvorovskaya', [
		[4, 69.88], [4, 75]
	]
	],
	['interchange', 'Prospekt_Mira', [
		[33, 61.7], [36, 65]
	]
	],
	['interchange_d', 'Prospekt_Mira', [
		[33, 61.7], [36, 65]
	]
	],
	['interchange', 'Komsomolskaya', [
		[55.19, 43], [60, 43]
	]
	],
	['interchange_d', 'Komsomolskaya', [
		[55.19, 43], [60, 43]
	]
	],
	['interchange', 'Kurskaya-Chkalobskaya', [
		[69.03, -11.43], [62.27, -5.73], [62.27, -16.53], [69.03, -11.43]
	]
	],
	['interchange_d', 'Kurskaya-Chkalobskaya', [
		[69.03, -11.43], [62.27, -5.73], [62.27, -16.53], [69.03, -11.43]
	]
	],
	['interchange', 'Taganskaya-Marksistskaya', [
		[60, -35.9], [60, -45], [64, -39], [60, -35.9]
	]
	],
	['interchange_d', 'Taganskaya-Marksistskaya', [
		[60, -35.9], [60, -45], [64, -39], [60, -35.9]
	]
	],
	['interchange', 'Paveletskaya', [
		[39.13, -58], [45, -58]
	]
	],
	['interchange_d', 'Paveletskaya', [
		[39.13, -58], [45, -58]
	]
	],
	['interchange', 'Dobryninskaya-Serpukhovskaya', [
		[19, -67.33], [19, -71]
	]
	],
	['interchange_d', 'Dobryninskaya-Serpukhovskaya', [
		[19, -67.33], [19, -71]
	]
	],
	['interchange', 'Oktyabrskaya', [
		[-11.46, -69.03], [-7.92, -65.45]
	]
	],
	['interchange_d', 'Oktyabrskaya', [
		[-11.46, -69.03], [-7.92, -65.45]
	]
	],
	['interchange', 'Park_Kultury', [
		[-53, -45.68], [-53, -50]
	]
	],
	['interchange_d', 'Park_Kultury', [
		[-53, -45.68], [-53, -50]
	]
	],
	['interchange', 'Sokolniki', [
		[76.37, 59.36], [76.37, 65.67]
	]
	],
	['interchange_d', 'Sokolniki', [
		[76.37, 59.36], [76.37, 65.67]
	]
	],
	['interchange', 'Turgenevskaya-Chistye_Prudy-Sretensky_Bulvar', [
		[31, 24], [34, 19], [31, 14.32], [31, 24]
	]
	],
	['interchange_d', 'Turgenevskaya-Chistye_Prudy-Sretensky_Bulvar', [
		[31, 24], [34, 19], [31, 14.32], [31, 24]
	]
	],
	['interchange', 'Kuznetsky_Most-Lubyanka', [
		[11.5, 20.5], [11.5, 14.5]
	]
	],
	['interchange_d', 'Kuznetsky_Most-Lubyanka', [
		[11.5, 20.5], [11.5, 14.5]
	]
	],
	['interchange', 'Okhotny_Ryad-Teatralnaya-Ploshcha_Pevolyutsi', [
		[-4, -1], [1, -6], [6, -11]
	]
	],
	['interchange_d', 'Okhotny_Ryad-Teatralnaya-Ploshcha_Pevolyutsi', [
		[-4, -1], [1, -6], [6, -11]
	]
	],
	['interchange', 'Biblioteka_Imeni_Lenina-Arbatskaya-Alexandrovsky_Sad-Borovitskaya', [
		[-14, -11], [-19, -6], [-24, -11], [-14, -11], [-19, -16], [-24, -11]
	]
	],
	['interchange_d', 'Biblioteka_Imeni_Lenina-Arbatskaya-Alexandrovsky_Sad-Borovitskaya', [
		[-14, -11], [-19, -6], [-24, -11], [-14, -11], [-19, -16], [-24, -11]
	]
	],
	['interchange', 'Kropotkinskaya-Volkhonka', [
		[-29.83, -26.83], [-29.83, -34.29]
	]
	],
	['interchange_d', 'Kropotkinskaya-Volkhonka', [
		[-29.83, -26.83], [-29.83, -34.29]
	]
	],
	['interchange', 'Prospekt_Vernadskogo', [
		[-110, -107.5], [-110, -100.95]
	]
	],
	['interchange_d', 'Prospekt_Vernadskogo', [
		[-110, -107.5], [-110, -100.95]
	]
	],
	['interchange', 'Dinamo-Petrovsky_Park', [
		[-56.7, 67.3], [-52.85, 71.15]
	]
	],
	['interchange_d', 'Dinamo-Petrovsky_Park', [
		[-56.7, 67.3], [-52.85, 71.15]
	]
	],
	['interchange', 'Tverskaya-Pushkinskaya-Chekhovskaya', [
		[-29, 24], [-18.55, 24], [-23.5, 29], [-29, 24]
	]
	],
	['interchange_d', 'Tverskaya-Pushkinskaya-Chekhovskaya', [
		[-29, 24], [-18.55, 24], [-23.5, 29], [-29, 24]
	]
	],
	['interchange', 'Tretyakovskaya-Novokuznetskaya', [
		[23.10, -33.98], [18.14, -39]
	]
	],
	['interchange_d', 'Tretyakovskaya-Novokuznetskaya', [
		[23.10, -33.98], [18.14, -39]
	]
	],
	['interchange', 'Krasnogvardeyskaya-Zyablikovo', [
		[81, -160], [84, -163]
	]
	],
	['interchange_d', 'Krasnogvardeyskaya-Zyablikovo', [
		[81, -160], [84, -163]
	]
	],
	['interchange', 'Kuntsevskaya', [
		[-159, 34], [-152.2, 34]
	]
	],
	['interchange_d', 'Kuntsevskaya', [
		[-159, 34], [-152.2, 34]
	]
	],
	['interchange', 'Smolenskaya-Plyushchikha', [
		[-42, -16], [-42, -22.55]
	]
	],
	['interchange_d', 'Smolenskaya-Plyushchikha', [
		[-42, -16], [-42, -22.55]
	]
	],
	['interchange', 'Elektrozavodskaya', [
		[80, 12], [80, 19]
	]
	],
	['interchange_d', 'Elektrozavodskaya', [
		[80, 12], [80, 19]
	]
	],
	['interchange', 'Vystavochnaya-Delovoy_Tsentr', [
		[-97, 11], [-104, 11]
	]
	],
	['interchange_d', 'Vystavochnaya-Delovoy_Tsentr', [
		[-97, 11], [-104, 11]
	]
	],
	['interchange', 'Rizhskaya', [
		[36, 77], [41, 82]
	]
	],
	['interchange_d', 'Rizhskaya', [
		[36, 77], [41, 82]
	]
	],
	['interchange', 'Kaluzhskaya', [
		[-44, -133], [-48, -133]
	]
	],
	['interchange_d', 'Kaluzhskaya', [
		[-44, -133], [-48, -133]
	]
	],
	['interchange', 'Novoyasenevskaya-Bittsevsky_Park', [
		[-44, -168], [-40, -168]
	]
	],
	['interchange_d', 'Novoyasenevskaya-Bittsevsky_Park', [
		[-44, -168], [-40, -168]
	]
	],
	['interchange', 'Polezhaevskaya-Khoroshyobskaya', [
		[-80, 50.54], [-80, 44]
	]
	],
	['interchange_d', 'Polezhaevskaya-Khoroshyobskaya', [
		[-80, 50.54], [-80, 44]
	]
	],
	['interchange', 'Proletarskaya-Krestyanskaya_Zastava', [
		[80, -65], [84, -59.83]
	]
	],
	['interchange_d', 'Proletarskaya-Krestyanskaya_Zastava', [
		[80, -65], [84, -59.83]
	]
	],
	['interchange', 'Tekstilshchiki', [
		[103.31, -80], [106.62, -76]
	]
	],
	['interchange_d', 'Tekstilshchiki', [
		[103.31, -80], [106.62, -76]
	]
	],
	['interchange', 'Lermontovsky_Prospekt-Kosino', [
		[147, -106], [156.5, -106]
	]
	],
	['interchange_d', 'Lermontovsky_Prospekt-Kosino', [
		[147, -106], [156.5, -106]
	]
	],
	['interchange', 'Michurinsky_Prospekt', [
		[-120, -58], [-113, -58]
	]
	],
	['interchange_d', 'Michurinsky_Prospekt', [
		[-120, -58], [-113, -58]
	]
	],
	['interchange', 'Rimskaya-Ploshchad_Ilyicha', [
		[84, -44.92], [90, -39]
	]
	],
	['interchange_d', 'Rimskaya-Ploshchad_Ilyicha', [
		[84, -44.92], [90, -39]
	]
	],
	['interchange', 'Aviamotornaya', [
		[99.22, -30], [106, -30]
	]
	],
	['interchange_d', 'Aviamotornaya', [
		[99.22, -30], [106, -30]
	]
	],
	['interchange', 'Savyolovskaya-Nizhnyaya_Maslovka', [
		[-29, 82], [-35, 82]
	]
	],
	['interchange_d', 'Savyolovskaya-Nizhnyaya_Maslovka', [
		[-29, 82], [-35, 82]
	]
	],
	['interchange', 'Tsvetnoy_Bulvar-Trubnaya', [
		[-4, 43.5], [4.17, 43.5]
	]
	],
	['interchange_d', 'Tsvetnoy_Bulvar-Trubnaya', [
		[-4, 43.5], [4.17, 43.5]
	]
	],
	['interchange', 'Sevastopolskaya-Kakhovskaya', [
		[16, -133], [20, -135]
	]
	],
	['interchange_d', 'Sevastopolskaya-Kakhovskaya', [
		[16, -133], [20, -135]
	]
	],
	['interchange', 'Bulvar_Dmitriya_Donskogo-Ulitsa_Starokachalovskaya', [
		[-12, -168], [-16, -168]
	]
	],
	['interchange_d', 'Bulvar_Dmitriya_Donskogo-Ulitsa_Starokachalovskaya', [
		[-12, -168], [-16, -168]
	]
	],
	['interchange', 'Marina_Roshcha', [
		[1, 87], [6, 82]
	]
	],
	['interchange_d', 'Marina_Roshcha', [
		[1, 87], [6, 82]
	]
	],
	['interchange', 'Pechatniki-Yozhnoportovaya', [
		[96.83, -87.83], [93, -92.46]
	]
	],
	['interchange_d', 'Pechatniki-Yozhnoportovaya', [
		[96.83, -87.83], [93, -92.46]
	]
//
	],
	['mck_interchange_d', 'Okruzhnaya', [
		[-24, 117.57], [-30, 113]
	]
	],
	['mck_interchange_d', 'Voykovskaya-Baltiiskaya', [
		[-82, 92], [-82, 83.4]
	]
	],
	['mck_interchange_d', 'Oktyabrskoye_Pole-Panfilovskaya', [
		[-98.3, 68.48], [-93, 71]
	]
	],
	['mck_interchange_d', 'Khoroshyobskaya-Polezhaevskaya', [
		[-107.2, 48], [-81, 48]
	]
	],
	['mck_interchange_d', 'Shelepikha', [
		[-116, 28], [-113.6, 28]
	]
	],
	['mck_interchange_d', 'Delovoy_Tsentr-Mezhdunarodnaya', [
		[-115.2, 20], [-112, 21]
	]
	],
	['mck_interchange_d', 'Kutuzovskaya', [
		[-120, 3], [-116.9, 5]
	]
	],
	['mck_interchange_d', 'Sportivnaya-Luzhniki', [
		[-90, -87], [-81.4, -84]
	]
	],
	['mck_interchange_d', 'Ploshad_Gagarina-Leninsky_Prospekt', [
		[-49, -106.2], [-43.04, -102]
	]
	],
	['mck_interchange_d', 'Avtozavodskaya', [
		[72, -92.2], [68, -90]
	]
	],
	['mck_interchange_d', 'Dubrovka', [
		[84, -72], [83.4, -82]
	]
	],
	['mck_interchange_d', 'Shosse_Entuziastov', [
		[109, -20.45], [115.7, -17]
	]
	],
	['mck_interchange_d', 'Izmaylovo-Partizanskaya', [
		[106.7, 48], [113.45, 45.45]
	]
	],
	['mck_interchange_d', 'Lokomotiv-Cherkizovskaya', [
		[94.2, 69.4], [89.16, 72.15]
	]
	],
	['mck_interchange_d', 'Bulvar_Rokossovskogo', [
		[102, 85], [87.2, 78]
	]
	],
	['mck_interchange_d', 'Botanichesky_Sad', [
		[42.6, 109], [36, 106]
	]
	],
	['mck_interchange_d', 'Vladykino', [
		[-11, 122], [-11, 116.4]
	]
	]
];
var MLEGEND = [
	['.Latitude', 'legend_border', [
		[-170, -185], [150, -185], [150, -220], [-170, -220], [-170, -185]
	]
	],
	['r1', 'r1_legend', [
		[-160, -190], [-140, -190]
	], 'Сокольническая линия (красная)', [-140, -190]
	],
	['r2', 'r2_legend', [
		[-160, -194], [-140, -194]
	], 'Замоскворецкая линия (зелёная)', [-140, -194]
	],
	['r3', 'r3_legend', [
		[-160, -198], [-140, -198]
	], 'Арбатско-Покровская линия (синяя)', [-140, -198]
	],
	['r4', 'r4_legend', [
		[-160, -202], [-140, -202]
	], 'Филёвская линия (голубая)', [-140, -202]
	],
	['rTPK', 'rTPK_legend', [
		[-160, -210], [-140, -210]
	], 'Третий пересадочный контур', [-140, -210]
	],
	['r5', 'r5_legend', [
		[-60, -190], [-40, -190]
	], 'Кольцевая линия (коричневая)', [-40, -190]
	],
	['r6', 'r6_legend', [
		[-60, -194], [-40, -194]
	], 'Калужско-Рижская линия (оранжевая)', [-40, -194]
	],
	['r7', 'r7_legend', [
		[-60, -198], [-40, -198]
	], 'Таганско-Краснопресненская линия (фиолетовая)', [-40, -198]
	],
	['r8', 'r8_legend', [
		[-60, -202], [-40, -202]
	], 'Калининская линия (жёлтая)', [-40, -202]
	],
	['r8_ext', 'r7_legend', [
		[-60, -206], [-40, -206]
	], 'Калининско-Солнцевская линия', [-40, -206]
	],
	['rKOZH', 'rKOZH_legend', [
		[-60, -210], [-40, -210]
	], 'Кожуховская линия', [-40, -210]
	],
	['r9', 'r9_legend', [
		[60, -190], [40, -190]
	], 'Серпуховско-Тимирязевская линия (серая)', [60, -190]
	],
	['r10', 'r10_legend', [
		[60, -194], [40, -194]
	], 'Люблинско-Дмитровская линия (салатовая)', [60, -194]
	],
	['r11', 'r11_legend', [
		[60, -198], [40, -198]
	], 'Каховская линия (бирюзовая)', [60, -198]
	],
	['r12', 'r12_legend', [
		[60, -202], [40, -202]
	], 'Бутовская линия (серо-голубая)', [60, -202]
	],
	['monorail_legend', 'mn_legend', [
		[60, -210], [40, -210]
	], 'Московский монорельс', [60, -210]
	]
];
var MLABEL = [
	['moskva_canal_label', 'mc', [], 'Канал имени Москвы', [-97, 111]],
	['moskva_river_label', 'mr', [], 'Москва-река', [111, -147]],
	['yauza_river_label', 'yr', [], 'Яуза', [59, 99]],
	['sheremetyevo_express_line_label', 'sheremetyevo_express', [], 'Шереметьево', [-32, 153]],
	['sheremetyevo_express_line_d_label', 'sheremetyevo_express', [], 'Белорусский', [-51, 55]],
	['vnukovo_express_line_label', 'vnukovo_express', [], 'Внуково', [-160, -121]],
	['vnukovo_express_line_d_label', 'vnukovo_express', [], 'Киевский', [-75, -20.1]],
	['domodedovo_express_line_label', 'domodedovo_express', [], 'Павелецкий', [51, -61]],
	['domodedovo_express_line_d_label', 'domodedovo_express', [], 'Домодедово', [51, -179]],
	['monorail_label', 'mn', [], 'M1', [-26, 101]]
];
var MSTATIONS = [
	['s1', 'Bulvar_Rokossovskogo', [[102, 85]], 'Бульвар Рокоссовского', null, 1],
	['s1', 'Cherkizovskaya', [[89.16, 72.15]], 'Черкизовская', null, 1],
	['s1', 'Preobrazhenskaya_Ploshchad', [[84.31, 67.31]], 'Преображенская площадь', null, 1],
	['s1_1', 'Sokolniki', [[76.37, 59.36]], 'Сокольники', null, 1],
	['s1', 'Krasnoselskaya', [[68.52, 51.52]], 'Красносельская', null, 1],
	['s1_1', 'Komsomolskaya', [[60, 43]], 'Комсомольская', null, 1],
	['s1', 'Krasniye_Vorota', [[48.89, 31.89]], 'Красные ворота', null, 1],
	['s1_1', 'Chistye_Prudy', [[34, 19]], 'Чистые пруды', null, 1],
	['s1_2', 'Lubyanka', [[11.5, 14.5]], 'Лубянка', null, 1],
	['s1_1', 'Okhotny_Ryad', [[-4, -1]], 'Охотный ряд', null, 1],
	['s1_4', 'Biblioteka_Imeni_Lenina', [[-14, -11]], 'Библиотека имени Ленина', null, 1],
	['s1_1', 'Kropotkinskaya', [[-29.83, -26.83]], 'Кропоткинская', null, 1],
	['s1_2', 'Park_Kultury', [[-53, -50]], 'Парк Культуры', null, 1],
	['s1', 'Frunzenskaya', [[-76.66, -73.66]], 'Фрунзенская', null, 1],
	['s1', 'Sportivnaya', [[-90, -87]], 'Спортивная', null, 1],
	['s1', 'Vorobyovy_Gory', [[-97, -94]], 'Воробьёвы горы', null, 1],
	['s1', 'Universitet', [[-104, -101]], 'Университет', null, 1],
	['s1_2', 'Prospekt_Vernadskogo', [[-110, -107.5]], 'Проспект Вернадского', null, 1],
	['s1', 'Yugo-Zapadnaya', [[-116, -113.5]], 'Юго-Западная', null, 1],
	['s1', 'Troparyovo', [[-125, -123]], 'Тропарёво', null, 1],
	['s1', 'Rumyantsevo', [[-132.5, -131]], 'Румянцево', null, 1],
	['s1', 'Salaryevo', [[-141, -140]], 'Саларьево', null, 1],
//
	['s2', 'Ulitsa_Dybenko', [[-92, 122]], 'Улица Дыбенко', null, 1],
	['s2', 'Belomorskaya', [[-92, 114]], 'Беломорская', null, 1],
	['s2', 'Rechnoy_Vokzal', [[-92, 107]], 'Речной вокзал', null, 1],
	['s2', 'Vodny_Stadion', [[-89, 99.07]], 'Водный стадион', null, 1],
	['s2', 'Voykovskaya', [[-82, 92]], 'Войковская', null, 1],
	['s2', 'Sokol', [[-70, 80.36]], 'Сокол', null, 1],
	['s2_4', 'Aeroport', [[-64, 74.46]], 'Аэропорт', null, 1],
	['s2_2', 'Dinamo', [[-56.7, 67.3]], 'Динамо', null, 1],
	['s2_1', 'Belorusskaya', [[-47, 57.78]], 'Белорусская', null, 1],
	['s2', 'Mayakovskaya', [[-31, 38]], 'Маяковская', null, 1],
	['s2_2', 'Tverskaya', [[-29, 24]], 'Тверская', null, 1],
	['s2_1', 'Teatralnaya', [[1, -6]], 'Театральная', null, 1],
	['s2_2', 'Novokuznetskaya', [[23.10, -33.98]], 'Новокузнецкая', null, 1],
	['s2_3', 'Paveletskaya', [[45, -58]], 'Павелецкая', null, 1],
	['s2_4', 'Avtozavodskaya', [[68, -90]], 'Автозаводская', null, 1],
	['s2_4', 'Tekhnopark', [[68, -104]], 'Технопарк', null, 1],
	['s2_4', 'Kolomenskaya', [[68, -113]], 'Коломенская', null, 1],
	['s2_5', 'Kashirskaya', [[68, -129]], 'Каширская', null, 1],
	['s2_4', 'Kantemirovskaya', [[68, -137]], 'Кантемировская', null, 1],
	['s2_4', 'Tsaritsyno', [[68, -143]], 'Царицыно', null, 1],
	['s2_4', 'Orekhovo', [[70.5, -149.34]], 'Орехово', null, 1],
	['s2_4', 'Domodedovskaya', [[76, -155]], 'Домодедовская', null, 1],
	['s2_2', 'Krasnogvardeyskaya', [[81, -160]], 'Красногвардейская', null, 1],
	['s2_6', 'Alma-Atinskaya', [[95, -160]], 'Алма-Атинская', null, 1],
//
	['s3', 'Pyatnitskoye_Shosse', [[-159, 98]], 'Пятницкое шоссе', null, 1],
	['s3', 'Mitino', [[-159, 90]], 'Митино', null, 1],
	['s3', 'Volokolamskaya', [[-159, 82]], 'Волоколамская', null, 1],
	['s3', 'Myakinino', [[-159, 74]], 'Мякинино', null, 1],
	['s3', 'Strogino', [[-159, 66]], 'Строгино', null, 1],
	['s3', 'Krylatskoye', [[-159, 58]], 'Крылатское', null, 1],
	['s3', 'Molodyozhnaya', [[-159, 50]], 'Молодёжная', null, 1],
	['s3_8', 'Kuntsevskaya', [[-159, 34]], 'Кунцевская', null, 1],
	['s3_2', 'Slavyansky_Bulvar', [[-141, -3]], 'Славянский бульвар', null, 1],
	['s3_5', 'Park_Pobedy', [[-120, -16]], 'Парк Победы', null, 1],
	['s3_3', 'Kievskaya', [[-72, -16]], 'Киевская', null, 1],
	['s3_3', 'Smolenskaya', [[-42, -16]], 'Смоленская', null, 1],
	['s3_7', 'Arbatskaya', [[-24, -11]], 'Арбатская', null, 1],
	['s3_4', 'Ploshchad_Revolyutsii', [[6, -11]], 'Площадь Революции', null, 1],
//['s3','Khmelnitskaya',[[36.1,-11]],'Хмельницкая',null,1],
	['s3_7', 'Kurskaya', [[62.27, -5.73]], 'Курская', null, 1],
	['s3', 'Baumanskaya', [[74, 6]], 'Бауманская', null, 1],
	['s3_6', 'Elektrozavodskaya', [[80, 12]], 'Электрозаводская', null, 1],
	['s3', 'Semyonovskaya', [[100.6, 32.6]], 'Семёновская', null, 1],
	['s3', 'Partizanskaya', [[113.45, 45.45]], 'Партизанская', null, 1],
	['s3', 'Izmaylovskaya', [[121.3, 53.3]], 'Измайловская', null, 1],
	['s3', 'Pervomayskaya', [[129.15, 61.15]], 'Первомайская', null, 1],
	['s3', 'Shchyolkovskaya', [[137, 69]], 'Щёлковская', null, 1],
//
	['s4', 'Mezhdunarodnaya', [[-112, 21]], 'Международная', null, 1],
	['s4_4', 'Vystavochnaya', [[-97, 11]], 'Выставочная', null, 1],
	['s4_5', 'Kuntsevskaya', [[-159, 34]], '', null, 1],
	['s4', 'Pionerskaya', [[-152.01, 27.01]], 'Пионерская', null, 1],
	['s4', 'Filyovsky_Park', [[-144.94, 19.94]], 'Филёвский парк', null, 1],
	['s4', 'Bagrationovskaya', [[-137.88, 12.88]], 'Багратионовская', null, 1],
	['s4', 'Fili', [[-131.08, 6.08]], 'Фили', null, 1],
	['s4_1', 'Kutuzovskaya', [[-120, 3]], 'Кутузовская', null, 1],
	['s4_1', 'Studencheskaya', [[-93, -3]], 'Студенческая', null, 1],
	['s4_2', 'Kievskaya', [[-72, -6]], '', null, 1],
	['s4_6', 'Smolenskaya', [[-52.85, -2]], 'Смоленская-2', null, 1],
	['s4_3', 'Arbatskaya', [[-32.7, -2]], 'Арбатская-2', null, 1],
	['s4_2', 'Alexandrovsky_Sad', [[-19, -6]], 'Александровский сад', null, 1],
//
	['s5', 'Komsomolskaya', [[55.19, 43]], '', null, 1],
	['s5', 'Kurskaya', [[69.03, -11.43]], 'Курская', null, 1],
	['s5', 'Taganskaya', [[60, -35.98]], 'Таганская', null, 1],
	['s5', 'Paveletskaya', [[39.13, -58]], '', null, 1],
	['s5', 'Dobryninskaya', [[19, -67.33]], 'Добрынинская', null, 1],
	['s5', 'Oktyabrskaya', [[-11.46, -69.03]], '', null, 1],
	['s5_1', 'Park_Kultury', [[-53, -45.68]], '', null, 1],
	['s5', 'Kievskaya', [[-69.09, -11]], '', null, 1],
	['s5', 'Rossyskaya', [[-69.38, 9.24]], 'Российская', null, 1],
	['s5_2', 'Krasnopresnenskaya', [[-64.8, 26.41]], 'Краснопресненская', null, 1],
	['s5_2', 'Belorusskaya', [[-47, 51.84]], 'Белорусская', null, 1],
	['s5_2', 'Novoslobodskaya', [[-26, 65]], 'Новослободская', null, 1],
	['s5', 'Suvorovskaya', [[4, 69.88]], 'Суворовская', null, 1],
	['s5', 'Prospekt_Mira', [[33, 61.7]], '', null, 1],
//
	['s6', 'Mytishchi', [[36, 145]], 'Мытищи', null, 1],
	['s6', 'Chelobityevo', [[36, 137]], 'Челобитьево', null, 1],
	['s6', 'Medvedkovo', [[36, 129]], 'Медведково', null, 1],
	['s6', 'Babushkinskaya', [[36, 121]], 'Бабушкинская', null, 1],
	['s6', 'Sviblovo', [[36, 113]], 'Свиблово', null, 1],
	['s6', 'Botanichesky_Sad', [[36, 106]], 'Ботанический сад', null, 1],
	['s6', 'VDNKh', [[36, 98]], 'ВДНХ', null, 1],
	['s6', 'Alexeyevskaya', [[36, 90]], 'Алексеевская', null, 1],
	['s6_2', 'Rizhskaya', [[36, 77]], 'Рижская', null, 1],
	['s6_2', 'Prospekt_Mira', [[36, 65]], 'Проспект Мира', null, 1],
	['s6_1', 'Sukharevskaya', [[36, 49]], 'Сухаревская', null, 1],
	['s6_2', 'Turgenevskaya', [[31, 24]], 'Тургеневская', null, 1],
	['s6_2', 'Kitay-Gorod', [[31, -16]], 'Китай-город', null, 1],
	['s6_4', 'Tretyakovskaya', [[18.14, -39]], 'Третьяковская', null, 1],
	['s6_3', 'Oktyabrskaya', [[-7.92, -65.45]], 'Октябрьская', null, 1],
	['s6', 'Shabolovskaya', [[-32.89, -90.83]], 'Шаболовская', null, 1],
	['s6', 'Leninsky_Prospekt', [[-43.04, -102]], 'Ленинский проспект', null, 1],
	['s6', 'Akademicheskaya', [[-44, -112]], 'Академическая', null, 1],
	['s6', 'Profsoyuznaya', [[-44, -119]], 'Профсоюзная', null, 1],
	['s6', 'Noviye_Cheryomushki', [[-44, -126]], 'Новые Черёмушки', null, 1],
	['s6_7', 'Kaluzhskaya', [[-44, -133]], 'Калужская', null, 1],
	['s6', 'Belyayevo', [[-44, -140]], 'Беляево', null, 1],
	['s6', 'Konkovo', [[-44, -147]], 'Коньково', null, 1],
	['s6', 'Tyoplyi_Stan', [[-44, -154]], 'Тёплый Стан', null, 1],
	['s6', 'Yasenevo', [[-44, -161]], 'Ясенево', null, 1],
	['s6_5', 'Novoyasenevskaya', [[-44, -168]], 'Новоясеневская', null, 1],
//
	['s7', 'Planernaya', [[-105, 99]], 'Планерная', null, 1],
	['s7', 'Skhodnenskaya', [[-105, 91]], 'Сходненская', null, 1],
	['s7', 'Tushinskaya', [[-105, 84]], 'Тушинская', null, 1],
	['s7', 'Spartak', [[-105, 78]], 'Спартак', null, 1],
	['s7', 'Shchukinskaya', [[-102.7, 72.65]], 'Щукинская', null, 1],
	['s7', 'Oktyabrskoye_Pole', [[-98.3, 68.48]], 'Октябрьское поле', null, 1],
	['s7_1', 'Polezhaevskaya', [[-80, 50.54]], 'Полежаевская', null, 1],
	['s7_4', 'Begovaya', [[-72.15, 42.87]], 'Беговая', null, 1],
	['s7_4', 'Ulitsa_1905_Goda', [[-65.61, 36.48]], 'Улица 1905 года', null, 1],
	['s7_2', 'Barrikadnaya', [[-60.34, 31.34]], 'Баррикадная', null, 1],
	['s7_2', 'Pushkinskaya', [[-23.5, 29]], 'Пушкинская', null, 1],
	['s7_1', 'Kuznetsky_Most', [[11.5, 20.5]], 'Кузнецкий мост', null, 1],
	['s7_5', 'Kitay-Gorod', [[31, -16]], '', null, 1],
	['s7_2', 'Taganskaya', [[60, -45]], '', null, 1],
	['s7_6', 'Proletarskaya', [[80, -65]], 'Пролетарская', null, 1],
	['s7_4', 'Volgogradsky_Prospekt', [[92, -77]], 'Волгоградский проспект', null, 1],
	['s7_3', 'Tekstilshchiki', [[103.31, -80]], 'Текстильщики', null, 1],
	['s7_7', 'Kuzminki', [[126, -80]], 'Кузьминки', null, 1],
	['s7_4', 'Ryazanskiy_Prospekt', [[142, -80]], 'Рязанский проспект', null, 1],
	['s7', 'Vykhino', [[160, -90]], 'Выхино', null, 1],
	['s7_1', 'Lermontovsky_Prospekt', [[147, -106]], 'Лермонтовский проспект', null, 1],
	['s7', 'Zhulebino', [[136, -117]], 'Жулебино', null, 1],
	['s7_8', 'Kotelniki', [[133, -126]], 'Котельники', null, 1],
//
	['s8', 'Rasskazovka', [[-162, -105]], 'Рассказовка', null, 1],
	['s8', 'Novoperedelkino', [[-154.62, -97.43]], 'Новопеределкино', null, 1],
	['s8', 'Borovskoye_Shosse', [[-146.77, -89.38]], 'Боровское шоссе', null, 1],
	['s8', 'Solntsevo', [[-138.92, -81.33]], 'Солнцево', null, 1],
	['s8', 'Teryoshkovo', [[-131.08, -73.28]], 'Говорово', null, 1],
	['s8', 'Ochakovo', [[-124.53, -66.57]], 'Очаково', null, 1],
	['s8_2', 'Michurinsky_Prospekt', [[-120, -58]], '', null, 1],
	['s8', 'Ramenki', [[-120, -44]], 'Раменки', null, 1],
	['s8', 'Lomonosobsky_Prospekt', [[-120, -35]], 'Ломоносовский проспект', null, 1],
	['s8', 'Minskaya', [[-120, -25]], 'Минская', null, 1],
	['s8_6', 'Park_Pobedy', [[-120, -16]], '', null, 1],
	['s8_3', 'Delovoy_Tsentr', [[-104, 11]], 'Деловой центр', null, 1],
	['s8_1', 'Kutuzovsky_Prospekt', [[-69.38, 3.63]], 'Дорогомиловская', null, 1],
	['s8_4', 'Plyushchikha', [[-42, -22.55]], 'Плющиха', null, 1],
	['s8_1', 'Volkhonka', [[-29.83, -34.29]], 'Волхонка', null, 1],
	['s8_6', 'Tretyakovskaya', [[18.14, -39]], '', null, 1],
	['s8_2', 'Marksistskaya', [[64, -39]], 'Марксистская', null, 1],
	['s8_1', 'Ploshchad_Ilicha', [[90, -39]], 'Площадь Ильича', null, 1],
	['s8_1', 'Aviamotornaya', [[99.22, -30]], '', null, 1],
	['s8', 'Shosse_Entuziastov', [[109, -20.45]], 'Шоссе Энтузиастов', null, 1],
	['s8', 'Perovo', [[120, -9.64]], 'Перово', null, 1],
	['s8', 'Novogireevo', [[128, -1.82]], 'Новогиреево', null, 1],
	['s8', 'Novokosino', [[136, 6]], 'Новокосино', null, 1],
//
	['s9', 'Altufyevo', [[0, 146]], 'Алтуфьево', null, 1],
	['s9', 'Bibirevo', [[0, 137]], 'Бибирево', null, 1],
	['s9', 'Otradnoye', [[-3, 130]], 'Отрадное', null, 1],
	['s9', 'Vladykino', [[-11, 122]], 'Владыкино', null, 1],
	['s9_2', 'Petrovsko-Razumovskaya', [[-21.52, 111.48]], 'Петровско-Разумовская', null, 1],
	['s9_4', 'Timiryazevskaya', [[-29, 101]], 'Тимирязевская', null, 1],
	['s9', 'Dmitrovskaya', [[-29, 91]], 'Дмитровская', null, 1],
	['s9_3', 'Savyolovskaya', [[-29, 82]], 'Савёловская', null, 1],
	['s9_5', 'Mendeleyevskaya', [[-26, 70]], 'Менделеевская', null, 1],
	['s9_1', 'Tsvetnoy_Bulvar', [[-4, 43.5]], 'Цветной бульвар', null, 1],
	['s9_2', 'Chekhovskaya', [[-18.55, 24]], 'Чеховская', null, 1],
	['s9_3', 'Borovitskaya', [[-19, -16]], 'Боровицкая', null, 1],
	['s9_4', 'Polyanka', [[6, -47.69]], 'Полянка', null, 1],
	['s9_2', 'Serpukhovskaya', [[19, -71]], 'Серпуховская', null, 1],
	['s9', 'Tulskaya', [[19, -99]], 'Тульская', null, 1],
	['s9', 'Nagatinskaya', [[19, -117]], 'Нагатинская', null, 1],
	['s9', 'Nagornaya', [[19, -123]], 'Нагорная', null, 1],
	['s9', 'Nakhimovsky_Prospekt', [[18.8, -129]], 'Нахимовский проспект', null, 1],
	['s9_6', 'Sevastopolskaya', [[16, -133]], 'Севастопольская', null, 1],
	['s9', 'Chertanovskaya', [[11.2, -139]], 'Чертановская', null, 1],
	['s9', 'Yuzhnaya', [[6.3, -145]], 'Южная', null, 1],
	['s9', 'Prazhskaya', [[1.5, -151]], 'Пражская', null, 1],
	['s9', 'Ulitsa_Akademika_Yangelya', [[-3.3, -157]], 'Улица Академика Янгеля', null, 1],
	['s9', 'Annino', [[-8, -163]], 'Аннино', null, 1],
	['s9_2', 'Bulvar_Dmitriya_Donskogo', [[-12, -168]], 'Бульвар Дмитрия Донского', null, 1],
//
	['s10', 'Dmitrovskoye_Shosse', [[-24, 146]], 'Дмитровское шоссе', null, 1],
	['s10', 'Ulitsa_800_Letiya_Moskvy', [[-24, 139]], 'Улица 800-летия Москвы', null, 1],
	['s10', 'Seligerskaya', [[-24, 132]], 'Селигерская', null, 1],
	['s10', 'Verkhniye_Likhobory', [[-24, 125]], 'Верхние Лихоборы', null, 1],
	['s10', 'Okruzhnaya', [[-24, 117.57]], 'Окружная', null, 1],
	['s10_4', 'Petrovsko-Razumovskaya', [[-21.52, 111.48]], '', null, 1],
	['s10_1', 'Fonvizinskaya', [[-13.87, 103.16]], 'Фонвизинская', null, 1],
	['s10_1', 'Butyrskaya', [[-6.02, 94.63]], 'Бутырская', null, 1],
	['s10_2', 'Marina_Roshcha', [[1, 87]], 'Марьина Роща', null, 1],
	['s10_2', 'Dostoyevskaya', [[4, 75]], 'Достоевская', null, 1],
	['s10_2', 'Trubnaya', [[4.17, 43.5]], 'Трубная', null, 1],
	['s10_2', 'Sretensky_Bulvar', [[31, 14.32]], 'Сретенский бульвар', null, 1],
	['s10_2', 'Chkalovskaya', [[62.27, -16.53]], 'Чкаловская', null, 1],
	['s10_2', 'Rimskaya', [[84, -44.92]], 'Римская', null, 1],
	['s10_2', 'Krestyanskaya_Zastava', [[84, -59.83]], 'Крестьянская застава', null, 1],
	['s10', 'Dubrovka', [[84, -72]], 'Дубровка', null, 1],
	['s10', 'Kozhukhovskaya', [[92, -83]], 'Кожуховская', null, 1],
	['s10_2', 'Pechatniki', [[96.83, -87.83]], 'Печатники', null, 1],
	['s10', 'Volzhskaya', [[108, -106]], 'Волжская', null, 1],
	['s10', 'Lyublino', [[99, -118]], 'Люблино', null, 1],
	['s10_1', 'Bratislavskaya', [[91, -126]], 'Братиславская', null, 1],
	['s10_1', 'Marino', [[84, -137]], 'Марьино', null, 1],
	['s10_1', 'Borisovo', [[84, -145]], 'Борисово', null, 1],
	['s10_1', 'Shipilovskaya', [[84, -153]], 'Шипиловская', null, 1],
	['s10_3', 'Zyablikovo', [[84, -163]], 'Зябликово', null, 1],
//
	['s11_1', 'Kakhovskaya', [[20, -135]], 'Каховская', null, 1],
	['s11', 'Varshavskaya', [[42, -135]], 'Варшавская', null, 1],
	['s11_2', 'Kashirskaya', [[68, -129]], '', null, 1],
//
	['s12_4', 'Bittsevsky_Park', [[-40, -168]], 'Битцевский парк', null, 1],
	['s12_1', 'Lesoparkovaya', [[-28, -168]], 'Лесопарковая', null, 1],
	['s12_5', 'Ulitsa_Starokachalovskaya', [[-16, -168]], 'Улица Старокачаловская', null, 1],
	['s12_2', 'Ulitsa_Skobelevskaya', [[-28, -179]], 'Улица Скобелевская', null, 1],
	['s12_1', 'Bulvar_Admirala_Ushakova', [[-45, -179]], 'Б-р Адм Ушакова', null, 1],
	['s12', 'Ulitsa_Gorchakova', [[-66, -179]], 'Улица Горчакова', null, 1],
	['s12_1', 'Buninskaya_Alleya', [[-87, -179]], 'Бунинская аллея', null, 1],
	['s12', 'Potapovo', [[-108, -179]], 'Потапово', null, 1],
	['s12_1', 'Chechyorsky_Proezd', [[-129, -179]], 'Чечёрский проезд', null, 1],
	['s12', 'Novokuryanovo', [[-150, -179]], 'Новокурьяново', null, 1],
//
	['sTPK_3', 'Kuntsevskaya', [[-152.2, 34]], 'Можайская', null, 1],
	['sTPK_8', 'Terekhovo', [[-137, 40]], 'Терехово', null, 1],
	['sTPK_6', 'Mnyovniki', [[-121, 40]], 'Н.Мнёвники', null, 1],
	['sTPK', 'Narodnoye_Opolcheniye', [[-105, 40]], 'Улица Н.Ополчения', null, 1],
	['sTPK_5', 'Delovoy_Tsentr', [[-104, 11]], '', null, 1],
	['sTPK_2', 'Shelepikha', [[-116, 28]], 'Шелепиха', null, 1],
	['sTPK_9', 'Khoroshyobskaya', [[-80, 44]], 'Хорошёвская', null, 1],
	['sTPK_1', 'Khodynskoye_Pole', [[-67.5, 56.5]], 'ЦСКА', null, 1],
	['sTPK_3', 'Petrovsky_Park', [[-52.85, 71.15]], 'Петровский Парк', null, 1],
	['sTPK_14', 'Nizhnyaya_Maslovka', [[-35, 82]], 'Н.Масловка', null, 1],
	['sTPK_11', 'Marina_Roshcha', [[6, 82]], 'Шереметьевская', null, 1],
	['sTPK_4', 'Rzhevskaya', [[41, 82]], 'Ржевская', null, 1],
	['sTPK_9', 'Sokolniki', [[76.37, 65.67]], 'Стромынка', null, 1],
	['sTPK_3', 'Elektrozavodskaya', [[80, 19]], 'Рубцовская', null, 1],
	['sTPK_7', 'Lefortovo', [[98.63, -1.76]], 'Лефортово', null, 1],
	['sTPK_3', 'Aviamotornaya', [[106, -30]], 'Авиамоторная', null, 1],
	['sTPK_3', 'Nizhegorodskaya_Ulitsa', [[122.18, -46.18]], 'Нижегородская улица', null, 1],
	['sTPK_3', 'Tekstilshchiki', [[106.62, -76]], '', null, 1],
	['sTPK', 'Yozhnoportovaya', [[93, -92.46]], 'Южнопортовая', null, 1],
	['sTPK_7', 'Nagatinsky_Zaton', [[77.5, -115]], 'Кленовый бульвар', null, 1],
	['sTPK_10', 'Zyuzino', [[-12, -133]], 'Зюзино', null, 1],
	['sTPK_13', 'Vorontsovskaya', [[-48, -133]], 'Воронцовская', null, 1],
	['sTPK_1', 'Ulitsa_Hovatorov', [[-78, -118]], 'Улица Новаторов', null, 1],
	['sTPK_3', 'Prospekt_Vernadskogo', [[-110, -100.95]], '', null, 1],
	['sTPK_3', 'Michurinsky_Prospekt', [[-113, -58]], 'Мичуринский проспект', null, 1],
	['sTPK_2', 'Aminyevskoye_Shosse', [[-135.26, -35.74]], 'Аминьевское шоссе', null, 1],
	['sTPK_2', 'Davydkovo', [[-145.73, -25.27]], 'Давыдково', null, 1],
//
	['sTPK_1', 'Ulitsa_Akademika_Oparina', [[-83, -124]], 'Улица Академика Опарина', null, 1],
	['sTPK_1', 'Ulitsa_Generala_Tuleneva', [[-87, -129]], 'Улица Генерала Тюленева', null, 1],
	['sTPK_1', 'Slavyanskiy_Mir', [[-91.2, -134]], 'Славянский мир', null, 1],
	['sTPK_1', 'Mamyri', [[-95.4, -139]], 'Мамыри', null, 1],
	['sTPK_1', 'Kommunarka', [[-99.6, -144]], 'Коммунарка', null, 1],
	['sTPK_1', 'Stolbovo', [[-103.8, -149]], 'Столбово', null, 1],
	['sTPK_1', 'Sosenki', [[-107.8, -154]], 'Сосенки', null, 1],
	['sTPK_1', 'Desna', [[-112, -159]], 'Десна', null, 1],
//
	['sKOZH_3', 'Aviamotornaya', [[106, -30]], '', null, 1],
	['sKOZH_3', 'Nizhegorodskaya_Ulitsa', [[122.18, -46.18]], '', null, 1],
	['sKOZH', 'Okskaya_Ulitsa', [[132.65, -56.65]], 'Окская улица', null, 1],
	['sKOZH', 'Stakhanobskaya_Ulitsa', [[137, -66]], 'Стахановская улица', null, 1],
	['sKOZH_1', 'Ferganskaya_Ulitsa', [[143.11, -91.39]], 'Ферганская улица', null, 1],
	['sKOZH_2', 'Kosino', [[156.5, -106]], 'Косино', null, 1],
	['sKOZH_1', 'Saltykovskaya_Ulitsa', [[165, -123]], 'Салтыковская улица', null, 1],
	['sKOZH_1', 'Kosino-Ukhtomskaya', [[165, -131]], 'Косино-Ухтомская', null, 1],
	['sKOZH_1', 'Nekrasovka', [[165, -138]], 'Некрасовка', null, 1],
//
	['sMono', 'Timiryazevskaya', [[-26, 101]], '', null, 1],
	['sMono', 'Ulitsa_Milashenkova', [[-13, 101]], '', null, 1],
	['sMono', 'Teletsentr', [[1, 101]], '', null, 1],
	['sMono', 'Ulitsa_Akademika_Koroleva', [[17, 101]], '', null, 1],
	['sMono', 'Vystavochny_Tsentr', [[33, 101]], '', null, 1],
	['sMono_1', 'Ulitsa_Sergeya_Eyzenshteyna', [[43, 101]], '', null, 1],
//
	['sMCK', 'Vladykino', [[-11, 116.4]], '', null, 1],
	['sMCK', 'Okruzhnaya', [[-30, 113]], '', null, 1],
	['sMCK', 'Lihobory', [[-44, 108.4]], 'Лихоборы', null, 1],
	['sMCK', 'Koptevo', [[-62.8, 98.6]], 'Коптево', null, 1],
	['sMCK', 'Baltiiskaya', [[-82, 83.4]], 'Балтийская', null, 1],
	['sMCK', 'Streshnevo', [[-87, 78.2]], 'Стрешнево', null, 1],
	['sMCK', 'Panfilovskaya', [[-93, 71]], 'Панфиловская', null, 1],
	['sMCK', 'Zorge', [[-102.7, 56]], 'Зорге', null, 1],
	['sMCK_1', 'Horoshevo', [[-106.6, 48]], 'Хорошёво', null, 1],
	['sMCK', 'Shelepiha', [[-113.6, 28]], 'Шелепиха', null, 1],
	['sMCK_1', 'Delovoy_Tsentr', [[-115.2, 20]], 'Деловой центр', null, 1],
	['sMCK', 'Kutuzovskaya', [[-116.9, 5]], 'Кутузовская', null, 1],
	['sMCK', 'Luzhniki', [[-81.4, -84]], 'Лужники', null, 1],
	['sMCK', 'Ploshad_Gagarina', [[-49, -106.2]], 'Площадь Гагарина', null, 1],
	['sMCK_4', 'Krymskaya', [[-14, -116.2]], 'Крымская', null, 1],
	['sMCK_3', 'Verhnie_Kotly', [[30, -113.1]], 'Верхние Котлы', null, 1],
	['sMCK_2', 'ZIL', [[50, -105.8]], 'ЗИЛ', null, 1],
	['sMCK', 'Avtozavodskaya', [[72, -92.2]], '', null, 1],
	['sMCK', 'Dubrovka', [[83.4, -82]], '', null, 1],
	['sMCK', 'Ugreshskaya', [[101.5, -58]], 'Угрешская', null, 1],
	['sMCK', 'Novohohlovskaya', [[106.6, -48]], 'Новохохловская', null, 1],
	['sMCK', 'Nizhegorodskaya', [[111.5, -35.5]], 'Нижегородская', null, 1],
	['sMCK', 'Delovoy_Tsentr', [[114.3, -25]], 'Андроновка ', null, 1],
	['sMCK', 'Shosse_Entuziastov', [[115.7, -17]], 'Шоссе Энтузиастов', null, 1],
	['sMCK', 'Sokolinaya_Gora', [[116.3, 12]], 'Соколиная гора', null, 1],
	['sMCK_2', 'Izmaylovo', [[106.7, 48]], 'Измайлово', null, 1],
	['sMCK', 'Lokomotiv', [[94.2, 69.4]], 'Локомотив', null, 1],
	['sMCK', 'Bulvar_Rokossovskogo', [[87.2, 78]], '', null, 1],
	['sMCK', 'Izmaylovo', [[74.8, 90]], 'Белокаменная', null, 1],
	['sMCK', 'Rostokino', [[60.6, 100]], 'Ростокино', null, 1],
	['sMCK', 'Botanicheskiy_Sad', [[42.6, 109]], 'Ботанический сад', null, 1]
];
/!*
 * dbCartajs HTML5 SVG vector object map v2.0.3.
 * It uses Proj4js transformations.
 *
 * Source at https://github.com/egaxegax/dbCartajs.git.
 * egax@bk.ru, 2015-2016.
 *!/
var SVG_NS = 'http://www.w3.org/2000/svg';

function dbCartaSvg(cfg) {
	var el, cont, root, vp,
		self = this;
	var extend = function (dst, src) {
		if (!src) {
			src = dst;
			dst = this;
		}
		for (var prop in src)
			if (src[prop] !== undefined)
				dst[prop] = src[prop];
		return dst;
	};
	var attr = function (dst, src) {
		if (!src) {
			src = dst;
			dst = this;
		}
		for (var prop in src)
			if (src[prop]) dst.setAttribute(prop, src[prop]);
		return dst;
	};
	var append = function (parent, name, at) {
		if (!at) {
			at = name;
			name = parent;
			parent = vp || root;
		}
		var el = document.createElementNS(SVG_NS, name);
		if (parent) parent.appendChild(el);
		attr(el, at);
		return el;
	};
	cfg = cfg || {};
	el = document.getElementById(cfg.id);
	cont = document.createElement('div'); // container
	if (el) el.appendChild(cont);
	// root node
	root = append(cont, 'svg', {
		width: cfg.width ? cfg.width : el.offsetWidth,
		height: cfg.height ? cfg.height : el.offsetWidth / 2.0,
		version: '1.1',
		xlmns: SVG_NS
	});
	root.style.backgroundColor = cfg.bg || 'rgb(186,196,205)';
	// child
	vp = append(root, 'g', {
		width: root.getAttribute('width'),
		height: root.getAttribute('height')
	});
	// add props
	extend(this, {
		/!**
		 * Public
		 *!/
		root: root, // svg node
		vp: vp, // g node (rotate, scale, translate)
		extend: extend,
		attr: attr,
		append: append,

		cfg: {
			draggable: cfg.draggable == undefined ? true : cfg.draggable,
			boundbg: cfg.boundbg || 'rgb(90,140,190)',
			sbar: cfg.sbar == undefined ? true : cfg.sbar,
			sbarpos: cfg.sbarpos || 'right'
		},
		/!**
		 * Interval vars
		 *!/
		m: {
			delta: root.getAttribute('width') / 360.0,
			halfX: root.getAttribute('width') / 2.0,
			halfY: root.getAttribute('height') / 2.0,
			rotate: 0,
			scale: 1,
			offset: [0, 0],
			touches: []
		},
		/!*
		 * Proj4 defs
		 *!/
		projlist: function () {
			if ('Proj4js' in window) {
				return {
					0: '+proj=longlat',
					101: '+proj=merc +units=m',
					102: '+proj=mill +units=m',
					201: '+proj=laea +units=m',
					202: '+proj=nsper +units=m +h=40000000',
					203: '+proj=ortho +units=m',
					204: '+proj=moll +units=m'
				}
			}
			return {};
		}(),
		projload: {},
		project: 0,
		/!**
		 * Convert pixels to points.
		 *!/
		canvasXY: function (ev) {
			var node = cont,
				pts = [ev.clientX, ev.clientY];
			if (!/WebKit/.test(navigator.userAgent)) {
				pts[0] += window.pageXOffset;
				pts[1] += window.pageYOffset;
			}
			while (node) {
				pts[0] -= node.offsetLeft - node.scrollLeft;
				pts[1] -= node.offsetTop - node.scrollTop;
				node = node.offsetParent;
			}
			return pts;
		},
		/!**
		 * Return meridians coords.
		 *!/
		createMeridians: function () {
			var lonlat = [];
			var x = -180,
				scale_x = 180;
			while (x <= scale_x) {
				var lon = [];
				var y = -90;
				while (y <= 90) {
					lon.push([x, y]);
					y += (y == -90 || y == 84 ? 6 : 84); // mercator fix
				}
				lonlat.push(lon);
				x += 30;
			}
			var y = -90;
			while (y <= 90) {
				var x = -180,
					prev = [x, y];
				while (x < scale_x) {
					x += 90;
					var lat = [prev, [x, y]],
						prev = [x, y];
					lonlat.push(lat);
				}
				y += 30;
			}
			return lonlat;
		},
		// - transforms ---------------------------------
		/!**
		 * Rotate map on ANGLE in degrees.
		 *!/
		rotateCarta: function (angle) {
			this.m.rotate += angle;
			this.scaleCarta(this.m.scale);
		},
		/!**
		 * Change map scale to SCALE.
		 *!/
		scaleCarta: function (scale) {
			var centerof = this.centerOf();
			var cx = centerof[0] / scale - centerof[0],
				cy = centerof[1] / scale - centerof[1];
			var offx = this.m.offset[0] + cx,
				offy = this.m.offset[1] + cy;
			attr(vp, {
				transform: 'rotate(' + this.m.rotate + ' ' + centerof[0] + ' ' + centerof[1] + ') scale(' + scale + ') translate(' + offx + ',' + offy + ')'
			});
			this.m.scale = scale;
		},
		/!**
		 * Center map by points PTS.
		 *!/
		centerCarta: function (pts) {
			var scale = this.m.scale;
			var centerof = this.centerOf();
			var cx = centerof[0] / scale - centerof[0],
				cy = centerof[1] / scale - centerof[1];
			var offx = pts[0] / scale - this.m.mpts[0],
				offy = pts[1] / scale - this.m.mpts[1];
			var fx = offx + cx,
				fy = offy + cy;
			attr(vp, {
				transform: 'rotate(' + this.m.rotate + ' ' + centerof[0] + ' ' + centerof[1] + ') scale(' + scale + ') translate(' + fx + ',' + fy + ')'
			});
			this.m.offset = [offx, offy];
		},
		/!**
		 * Select obj under mouse cursor like html MAP-AREA.
		 *!/
		doMap: function (ev, at) {
			this.mousemove(ev);
			if (!this.m.pmap) {
				var mattr = {};
				for (var prop in at) { // save current
					mattr[prop] = ev.target.getAttribute(prop);
				}
				if (!mattr['transform']) mattr['transform'] = 'scale(1)';
				attr(ev.target, at); // set new
				this.m.pmap = {
					ev: ev,
					attr: mattr
				};
			}
			;
			this.m.pmap.i = 1; // set counter
		},
		/!**
		 * Append Sphere radii bounds.
		 *!/
		paintBound: function () {
			var centerof = this.centerOf();
			var rx, ry, proj = this.initProj();
			// spherical radii
			switch (String(this.project)) {
				case '201':
					rx = 2.0;
					break;
				case '202':
					rx = Math.sqrt((proj.p15 - 1.0) / (proj.p15 + 1.0));
					break;
				case '203':
					rx = 1.0;
					break;
				case '204':
					ry = 1.4142135623731;
					rx = 2.0 * ry;
					break;
			}
			if (rx) {
				return append('ellipse', {
					cx: centerof[0],
					cy: centerof[1],
					rx: rx * this.m.delta * 180 / Math.PI,
					ry: (ry || rx) * this.m.delta * 180 / Math.PI,
					fill: this.cfg.boundbg
				});
			}
		},
		/!**
		 * Append right bar with scale buttons.
		 *!/
		paintBar: function () {
			if (!this.cfg.sbar) return;
			var sz = this.sizeOf(),
				cw = sz[2],
				ch = sz[3];
			var h = ch / 6,
				w = h / 2,
				tleft = this.cfg.sbarpos == 'left' ? w / 10 : cw - w - w / 10,
				ttop = ch / 2 - h / 2,
				d = w / 10; // + - size
			var cols = 20, // arc col vertex
				anglestep = Math.PI / cols;
			var mx, my; // last pos
			var pts = [];
			// plus round
			for (var i = -6; i <= cols + 6; i++)
				pts.push(mx = (w / 2 * Math.cos(i * anglestep)), my = (-w / 2 * Math.sin(i * anglestep)));
			pts.push(-w / 5, -d / 2);
			pts.push(-d / 2, -d / 2);
			pts.push(-d / 2, -w / 5);
			pts.push(d / 2, -w / 5);
			pts.push(d / 2, -d / 2);
			pts.push(w / 5, -d / 2);
			pts.push(w / 5, d / 2);
			pts.push(d / 2, d / 2);
			pts.push(d / 2, w / 5);
			pts.push(-d / 2, w / 5);
			pts.push(-d / 2, d / 2);
			pts.push(-w / 5, d / 2);
			pts.push(-w / 5, -d / 2);
			pts.push(mx, my);
			// minus round
			for (var i = -6; i <= -6; i++)
				pts.push(-w / 2 * Math.cos(i * anglestep), h / 2 + w / 2 * Math.sin(i * anglestep));
			pts.push(-w / 5, h / 2 - d / 2);
			pts.push(w / 5, h / 2 - d / 2);
			pts.push(w / 5, h / 2 + d / 2);
			pts.push(-w / 5, h / 2 + d / 2);
			pts.push(-w / 5, h / 2 - d / 2);
			for (var i = -6; i <= cols + 6; i++)
				pts.push(mx = (-w / 2 * Math.cos(i * anglestep)), my = (h / 2 + w / 2 * Math.sin(i * anglestep)));
			// home round
			for (var i = 0; i <= cols; i++)
				pts.push(w / 6 * Math.cos(i * 2.0 * anglestep), h / 2 - h / 4 + w / 6 * Math.sin(i * 2.0 * anglestep));
			pts.push(mx, my);
			var dx = tleft + w / 2,
				dy = ttop + h / 4,
				path = 'M ' + pts[0] + ' ' + pts[1] + ' L ' + pts.join(' ') + ' z';

		},
		// - sizes ----------------------------
		sizeOf: function () {
			return [0, 0, root.getAttribute('width'), root.getAttribute('height')];
		},
		centerOf: function () {
			var rect = this.sizeOf();
			return [(rect[0] + rect[2]) / 2.0,
				(rect[1] + rect[3]) / 2.0];
		},
		/!**
		 * Map visible borders in degrees.
		 *!/
		viewsizeOf: function () {
			var rect = this.sizeOf();
			var left = this.fromPoints([rect[0], rect[1]], false),
				leftproj = this.fromPoints([rect[0], rect[1]], !this.isSpherical()),
				right = this.fromPoints([rect[2], rect[3]], false),
				rightproj = this.fromPoints([rect[2], rect[3]], !this.isSpherical());
			var mleft = left[0], mtop = leftproj[1],
				mright = right[0], mbottom = rightproj[1];
			return [mleft, mtop, mright, mbottom];
		},
		viewcenterOf: function () {
			var rect = this.viewsizeOf();
			return [(rect[0] + rect[2]) / 2.0,
				(rect[1] + rect[3]) / 2.0];
		},
		// - checks ------------------------
		/!**
		 * Check click on right bar and do action.
		 *!/
		chkBar: function (pts, doaction) {
			if (!this.cfg.sbar) return;
			var sz = this.sizeOf(),
				cw = sz[2],
				ch = sz[3];
			var h = ch / 6,
				w = h / 2,
				tleft = this.cfg.sbarpos == 'left' ? w / 10 : cw - w - w / 10,
				ttop = ch / 2 - h / 2,
				d = w / 10;
			var mx = pts[0] - tleft,
				my = pts[1] - ttop;
			if (mx > 0 && mx < w && my > 0 && my < h) { // scale
				if (!doaction) return true;
				var zoom = (this.m.scale > 1 ? this.m.scale : 2 - 1 / this.m.scale);
				if (my > h / 2 - w / 6 && my < h / 2 + w / 6) { // home
					zoom = 1;
				} else if (my > 0 && my < h / 2) { // plus
					if (zoom < 50) zoom += 0.1;
				} else if (my > h / 2 && my < h) { // minux
					if (zoom > -18) zoom -= 0.1;
				}
				zoom = (zoom > 1 ? zoom : 1 / (2 - zoom));
				this.scaleCarta(zoom);
				if (zoom == 1) {
					var centerof = this.centerOf();
//          this.centerCarta(centerof[0] + this.m.offset[0] - this.m.scaleoff[0],
//                           centerof[1] + this.m.offset[1] - this.m.scaleoff[1], true);
				}
			}
		},
		chkPts: function (pts) {
			return (pts && !isNaN(pts[0]) && !isNaN(pts[1]));
		},
		resize: function (w, h) {
			attr(root, {
				width: w,
				height: h
			});
			this.m.delta = w / 360;
			this.m.halfX = w / 2.0;
			this.m.halfY = h / 2.0;
		},
		// - reproject ------------------------
		/!**
		 * Change project to NEW_PROJECT and center by visible centre.
		 *!/
		changeProject: function (new_project) {
			// curr. centerof
			var centerof = this.centerOf();
			if (this.isTurnable()) {
				var proj = this.initProj();
				viewcenterof = [proj.long0 * 180 / Math.PI, proj.lat0 * 180 / Math.PI];
			} else {
				var viewcenterof = this.fromPoints(centerof, true);
			}
			// new centerof
			if (this.isTurnable(new_project)) {
//        this.centerCarta([centerof[0] + this.m.offset[0], centerof[1] + this.m.offset[1]]);
				this.initProj(new_project, ' +lon_0=' + viewcenterof[0] + ' +lat_0=' + viewcenterof[1]);
			} else {
				this.initProj(new_project, ' +lon_0=0 +lat_0=0');
				var centerof = this.toPoints(viewcenterof, true);
				if (!this.chkPts(centerof)) centerof = [0, 0];
//        this.centerCarta([centerof[0] + this.m.offset[0], centerof[1] + this.m.offset[1]]);
			}
		},
		/!**
		 * Change project. to PROJECT with DEFS (see Proj4js proj. definitions).
		 * If no args return current projection info (Proj4js.Proj obj.).
		 *!/
		initProj: function (project, defs) {
			if ('Proj4js' in window) {
				if (project !== undefined) {
					if (defs == undefined) {
						defs = project;
						project = this.project;
					}
					var old_defs = Proj4js.defs[String(project)],
						new_defs = this.projlist[project] + (defs || '');
					this.m.doreload = (this.project != project) || (old_defs != new_defs); // recalc points?
					this.project = project;
					Proj4js.defs[String(project)] = new_defs;
				}
				if (String(this.project) in Proj4js.defs) {
					this.projload['epsg:4326'] = new Proj4js.Proj('epsg:4326');
					this.projload[String(this.project)] = new Proj4js.Proj(String(this.project));
					return this.projload[String(this.project)];
				}
			}
		},
		isSpherical: function (project) {
			project = project || this.project;
			return (project > 200 && project < 300);
		},
		isTurnable: function (project) {
			project = project || this.project;
			return (project == 202 || project == 203);
		},
		toPoints: function (coords, dotransform) {
			var m = coords;
			if (dotransform && this.project != 0) {
				if (!(coords = this.transformCoords('epsg:4326', String(this.project), coords))) return;
				else if (!coords[2]) return; //backside filter
			}
			var pts = [coords[0] * this.m.delta + this.m.halfX,
				-coords[1] * this.m.delta + this.m.halfY];
			if (m[2]) pts.push(m[2]); // bezier flag
			return pts;
		},
		/!**
		 * Convert points to degrees.
		 * Use projection transform. DOTRANSFORM [0|1] and matrix transform. DONTSCALE [0|1].
		 *!/
		fromPoints: function (pts, dotransform, dontscale) {
			if (dontscale) { // dont use matrix transformations
				var coords = [(pts[0] - this.m.halfX) / this.m.delta,
					-(pts[1] - this.m.halfY) / this.m.delta];
			} else {
				var coords = [(pts[0] / this.m.scale - this.m.halfX / this.m.scale - this.m.offset[0]) / this.m.delta,
					-(pts[1] / this.m.scale - this.m.halfY / this.m.scale - this.m.offset[1]) / this.m.delta];
			}
			if (dotransform && this.project != 0 && coords[0] != 0 && coords[1] != 0) {
				if (!(coords = this.transformCoords(String(this.project), 'epsg:4326', coords))) return;
			}
			return coords;
		},
		/!**
		 * Return spherical arc between CRD1 and CRD2 in degrees.
		 *!/
		distance: function (coord1, coord2) {
			var x = coord1[0] * Math.PI / 180.0,
				y = coord1[1] * Math.PI / 180.0,
				x1 = coord2[0] * Math.PI / 180.0,
				y1 = coord2[1] * Math.PI / 180.0;
			return Math.acos(Math.cos(y) * Math.cos(y1) * Math.cos(x - x1) + Math.sin(y) * Math.sin(y1)) * 180.0 / Math.PI;
		},
		/!**
		 * Interpolate (and convert to points if DOPOINTS) coords with STEP in degrees.
		 *!/
		interpolateCoords: function (coords, dopoints, step) {
			var i, pts, interpol_pts = [];
			for (var j in coords) {
				if (!coords[j]) {
					continue;
				} else if (!i || !step) {
					if (pts = (dopoints ? this.toPoints(coords[j], true) : coords[j]))
						interpol_pts.push(pts);
				} else {
					var x = coords[i][0],
						y = coords[i][1],
						x1 = coords[j][0],
						y1 = coords[j][1];
					var d = this.distance([x, y], [x1, y1]),
						scalestep = 1;
					if (d > step)
						scalestep = parseInt(d / step);
					var _x = x, _y = y;
					for (var k = 0; k < scalestep; k++) {
						_x += (x1 - x) / scalestep;
						_y += (y1 - y) / scalestep;
						if (pts = (dopoints ? this.toPoints([_x, _y], true) : [_x, _y]))
							interpol_pts.push(pts);
					}
				}
				i = j;
			}
			return interpol_pts;
		},
		/!**
		 * Reproject COORDS from SOURCE to DEST proj4 string definition.
		 *!/
		transformCoords: function (sourcestr, deststr, coords) {
			if ('Proj4js' in window) {
				var sourceproj = this.projload[sourcestr],
					destproj = this.projload[deststr];
				if (destproj.projName == 'longlat') {
					coords[0] = sourceproj.a * coords[0] * Proj4js.common.D2R;
					coords[1] = sourceproj.a * coords[1] * Proj4js.common.D2R;
				}
				var sourcept = new Proj4js.Point(coords[0], coords[1]);
				var destpt = Proj4js.transform(sourceproj, destproj, sourcept);
				if (!isNaN(destpt.x) && !isNaN(destpt.y)) {
					if (sourceproj.projName == 'longlat') {
						return [destpt.x / destproj.a * Proj4js.common.R2D,
							destpt.y / destproj.a * Proj4js.common.R2D,
							!isNaN(destpt.z)];
					} else {
						return [destpt.x, destpt.y];
					}
				}
			} else
				return coords;
		},
		/!**
		 * Return new COORDS rotated around Z-axis with ANGLE relative to CENTEROF.
		 *!/
		rotateCoords: function (coords, angle, centerof) {
			var roll = angle * Math.PI / 180,
				x = coords[0], y = coords[1], cx = centerof[0], cy = centerof[1],
				r = Math.sqrt((cx - x) * (cx - x) + (y - cy) * (y - cy));
			if (r > 0) {
				var a = Math.acos((cx - x) / r);
				if (y < cy) a = 2.0 * Math.PI - a;
				coords = [cx - r * Math.cos(roll + a),
					cy + r * Math.sin(roll + a)];
			}
			return coords;
		},
		// - handlers -----------------------------
		mousemove: function (ev) {
			var spts = this.canvasXY(ev),
				pts = this.rotateCoords(spts, this.m.rotate, this.centerOf());
			if (this.m.mpts && this.cfg.draggable) {
				this.centerCarta(pts, true);
			}
			if (this.m.pmap) {
				if (this.m.pmap.i === 0) {
					attr(this.m.pmap.ev.target, this.m.pmap.attr);
					delete this.m.pmap;
				} else
					this.m.pmap.i = 0;
			}
		},
		mousedown: function (ev) {
			if (ev.preventDefault) {
				ev.preventDefault();
			}
			var spts = this.canvasXY(ev),
				pts = this.rotateCoords(spts, this.m.rotate, this.centerOf());
			if (this.m.mbar = this.chkBar(spts)) { // if bar
				return;
			} else if (this.isTurnable()) { // proj.center for spherical turn
				var dst = this.fromPoints(pts, true);
				if (dst) {
					var proj = this.initProj();
					this.initProj(' +h=' + proj.h + ' +lon_0=' + dst[0] + ' +lat_0=' + dst[1]);
				}
			} else { // for drag
				this.m.mpts = [
					pts[0] / this.m.scale - this.m.offset[0],
					pts[1] / this.m.scale - this.m.offset[1]];
			}
		},
		mouseup: function (ev) {
			var spts = this.canvasXY(ev),
				pts = this.rotateCoords(spts, this.m.rotate, this.centerOf());
			if (this.m.mbar) { // bar
				this.chkBar(spts, true);
			}
			with (this.m) {
				delete mpts;
			}
		}
	});
	// - events -----------------------------
	extend(root, {
		mousewheel: function (ev) {
			var delta = 0;
			if (ev.wheelDelta) { // WebKit / Opera / Explorer 9
				delta = ev.wheelDelta / 40;
			} else if (ev.detail) { // Firefox
				delta = -ev.detail / 3;
			}
			var zoom = (self.m.scale > 1 ? self.m.scale : 2 - 1 / self.m.scale);
			zoom += delta * 0.1;
			zoom = (zoom > 1 ? zoom : 1 / (2 - zoom));
			self.scaleCarta(zoom);
		},
		touchmove: function (ev) {
			var touches = ev.changedTouches;
			if (self.m.touches.length < 2) {
				ev.preventDefault();
				self.mousemove(touches[touches.length - 1]);
			}
		},
		touchstart: function (ev) {
			self.m.dotouch = true;
			var touches = ev.changedTouches;
			for (var i = 0; i < touches.length; i++)
				self.m.touches.push(touches[i]);
			if (touches.length)
				self.mousedown(touches[0]);
		},
		touchend: function (ev) {
			var touches = ev.changedTouches;
			for (var i = 0; i < touches.length; i++) {
				for (var j = 0; j < self.m.touches.length; j++) {
					if (self.m.touches[j].identifier == touches[i].identifier)
						self.m.touches.splice(j, 1);
				}
			}
			if (!self.m.touches.length)
				self.mouseup(touches[touches.length - 1]);
		},
		onmousemove: function (ev) {
			self.mousemove(ev);
		},
		onmousedown: function (ev) {
			if (!self.m.dotouch) self.mousedown(ev);
		},
		onmouseup: function (ev) {
			if (!self.m.dotouch) self.mouseup(ev);
		}
	});
	root.addEventListener('mousewheel', root.mousewheel, false);
	root.addEventListener('DOMMouseScroll', root.mousewheel, false); // firefox
	root.addEventListener('touchmove', root.touchmove, false);
	root.addEventListener('touchstart', root.touchstart, false);
	root.addEventListener('touchend', root.touchend, false);
	root.addEventListener("touchleave", root.touchend, false);

	this.paintBar();
	return this;
}
var allmaps = [];
function initmaps() {
	addMetaTags('Карта метро, Схема метро Москвы, mosmetro');
	for (var i in allmaps) {
		allmaps[i]();
	}
}
if (window.addEventListener) {
	window.addEventListener('load', initmaps, false);
} else {
	window.attachEvent('onload', initmaps);
}
var dw;
// domap tooltip
var el = document.createElement('div');
el.id = 'maptooltip';
el.style.padding = '5px';
el.style.color = '#333333';
el.style.font = '12px Verdana';
el.style.border = '2px solid rgba(19,64,117,0.5)';
el.style.borderRadius = '4px';
el.style.backgroundColor = 'rgba(250,250,250,0.9)';
el.style.position = 'absolute';
el.style.zIndex = '10000';
el.style.display = 'none';
el.onmousemove = function () {
	this.innerHTML = '';
};
document.body.appendChild(el);
// tooltip under cursor
function infobox(ev) {
	var mtip = document.getElementById('maptooltip');
	if (dw.m.pmap) {
		mtip.innerHTML = dw.m.pmap.ev.target.getAttribute('class');
		mtip.style.display = 'block';
		mtip.style.left = ev.clientX + window.pageXOffset + 'px';
		mtip.style.top = ev.clientY + window.pageYOffset - mtip.offsetHeight * 1.2 + 'px';
	} else {
		mtip.style.display = 'none';
	}
}
function draw() {
	var mopt = {};
	var route = function (o) {
			return dw.extend({cls: 'Line', width: 6, anchor: ['start', 'middle'], labelscale: 1}, o || {})
		},
		route_d = function (o) {
			return route(dw.extend({dash: [2, 4]}, o || {}))
		},
		interchange = function (o) {
			return route(dw.extend({fg: '#ccc', join: 'round', cap: 'round', width: 8}, o || {}))
		},
		interchange_d = function (o) {
			return interchange(dw.extend({fg: '#ffffff', width: 4}, o || {}))
		},
		river = function (o) {
			return route(dw.extend({
				fg: '#e2fcfc',
				join: 'round',
				cap: 'round',
				labelcolor: '#5555ff',
				labelscale: 0
			}, o || {}))
		},
		aeroexpress = function (o) {
			return route(dw.extend({fg: '#dddddd', labelscale: 0}, o || {}))
		},
		aeroexpress_d = function (o) {
			return route(dw.extend({fg: '#ffffff', labelscale: 0, width: 4, dash: [10, 10]}, o || {}))
		},
		label = function (o) {
			return dw.extend({cls: 'Label', labelscale: 1, anchor: ['start', 'top']}, o || {})
		},
		station = function (o) {
			return dw.extend({cls: 'Rect', bg: 'white', size: 5, width: 3, scale: 1, labelscale: 1}, o || {})
		},
		mck_station = function (o) {
			return station(dw.extend({fg: '#f76093', size: 4, labelcolor: 'gray'}, o))
		},
		mck_interchange_d = function (o) {
			return interchange(dw.extend({dash: [2, 4], width: 3}, o || {}))
		},
		inst = function (o) {
			return station(dw.extend({size: 4, labelcolor: o['fg'], bg: o['fg']}, o))
		},
		inst_d = function (o) {
			return inst(dw.extend({size: 2, width: 1}, o || {}))
		};
	// lines
	dw.extend(mopt, {
		'r1': route({fg: '#ed1b35'}),
		'r2': route({fg: '#44b85c'}),
		'r3': route({fg: '#0078bf'}),
		'r4': route({fg: '#19c1f3'}),
		'r5': route({fg: '#894e35'}),
		'r6': route({fg: '#f58631'}),
		'r7': route({fg: '#8e479c'}),
		'r8': route({fg: '#ffcb31'}),
		'r9': route({fg: '#a1a2a3'}),
		'r10': route({fg: '#b3d445'}),
		'r11': route({fg: '#79cdcd'}),
		'r12': route({fg: '#acbfe1'}),
		'rTPK': route_d({fg: '#554d26'}),
		'rKOZH': route_d({fg: '#de62be'})
	});
	// lines ext
	dw.extend(mopt, {
		'r1_ext': route_d({fg: mopt['r1'].fg}),
		'r2_ext': route_d({fg: mopt['r2'].fg}),
		'r6_ext': route_d({fg: mopt['r6'].fg}),
		'r7_ext': route_d({fg: mopt['r7'].fg}),
		'r8_ext': route_d({fg: mopt['r8'].fg}),
		'r10_ext': route_d({fg: mopt['r10'].fg}),
		'r12_ext': route_d({fg: mopt['r12'].fg})
	});
	// interchanges
	dw.extend(mopt, {
		'interchange': interchange(),
		'interchange_d': interchange_d(),
		'mck_interchange_d': mck_interchange_d()
	});
	// rivers
	dw.extend(mopt, {
		'moskva_canal': river({width: 5}),
		'moskva_canal_label': river({rotate: -90, anchor: ['start', 'middle']}),
		'strogino_lake_exit': river({cls: 'Polygon', bg: river().fg, width: 5}),
		'vodootvodny_canal': river({width: 5}),
		'yauza_river': river({width: 5}),
		'yauza_river_label': river({rotate: 45, anchor: ['start', 'top']}),
		'Nagatino_poyma': river({width: 6}),
		'grebnoy_canal': river({width: 3}),
		'moskva_river': river({width: 15}),
		'moskva_river_label': river({rotate: 45, anchor: ['start', 'top']})
	});
	// rails
	dw.extend(mopt, {
		'monorail': route({fg: '#2c87c5', width: 2}),
		'monorail_legend': route({fg: '#2c87c5', width: 2}),
		'monorail_label': route({labelcolor: '#2c87c5', anchor: ['start', 'bottom']}),
		'mck': route({fg: '#f76093'}),
		'mck_d': route({fg: 'white', width: 2}),
		'sheremetyevo_express_line': aeroexpress(),
		'sheremetyevo_express_line_label': label({anchor: ['end', 'middle']}),
		'sheremetyevo_express_line_d': aeroexpress_d(),
		'sheremetyevo_express_line_d_label': label({anchor: ['end', 'top']}),
		'vnukovo_express_line': aeroexpress(),
		'vnukovo_express_line_label': label({anchor: ['start', 'middle']}),
		'vnukovo_express_line_d': aeroexpress_d(),
		'vnukovo_express_line_d_label': label({anchor: ['center', 'top']}),
		'domodedovo_express_line': aeroexpress(),
		'domodedovo_express_line_label': label({anchor: ['start', 'middle']}),
		'domodedovo_express_line_d': aeroexpress_d(),
		'domodedovo_express_line_d_label': label()
	});
	// stations
	dw.extend(mopt, {
		's1': station({fg: mopt['r1'].fg, anchor: ['start', 'middle']}),
		's1_1': inst({fg: mopt['r1'].fg, anchor: ['start', 'middle']}),
		's1_2': inst({fg: mopt['r1'].fg, anchor: ['end', 'middle']}),
		's1_3': inst({fg: mopt['r1'].fg, anchor: ['end', 'bottom']}),
		's1_4': inst({fg: mopt['r1'].fg, anchor: ['start', 'top']}),
		's2': station({fg: mopt['r2'].fg}),
		's2_1': inst({fg: mopt['r2'].fg}),
		's2_2': inst({fg: mopt['r2'].fg, anchor: ['end', 'middle']}),
		's2_3': inst({fg: mopt['r2'].fg, anchor: ['start', 'bottom']}),
		's2_4': station({fg: mopt['r2'].fg, anchor: ['end', 'middle']}),
		's2_5': inst({fg: mopt['r2'].fg, anchor: ['end', 'top']}),
		's2_6': station({fg: mopt['r2'].fg, anchor: ['start', 'top']}),
		's3': station({fg: mopt['r3'].fg, anchor: ['start', 'middle']}),
		's3_1': station({fg: mopt['r3'].fg, anchor: ['end', 'middle']}),
		's3_2': station({fg: mopt['r3'].fg, anchor: ['end', 'top']}),
		's3_3': inst({fg: mopt['r3'].fg, anchor: ['end', 'bottom']}),
		's3_4': inst({fg: mopt['r3'].fg, anchor: ['start', 'bottom']}),
		's3_5': inst({fg: mopt['r3'].fg, anchor: ['end', 'top']}),
		's3_6': inst({fg: mopt['r3'].fg, anchor: ['end', 'middle']}),
		's3_7': inst({fg: mopt['r3'].fg, anchor: ['end']}),
		's3_8': inst({fg: mopt['r3'].fg, anchor: ['center', 'bottom']}),
		's4': station({fg: mopt['r4'].fg}),
		's4_1': station({fg: mopt['r4'].fg, anchor: ['end', 'top']}),
		's4_2': inst({fg: mopt['r4'].fg, anchor: ['end', 'middle']}),
		's4_3': station({fg: mopt['r4'].fg, anchor: ['start', 'bottom']}),
		's4_4': inst({fg: mopt['r4'].fg, anchor: ['start', 'bottom']}),
		's4_5': inst_d({fg: mopt['r4'].fg}),
		's4_6': station({fg: mopt['r4'].fg, anchor: ['center', 'bottom']}),
		's5': inst({fg: mopt['r5'].fg}),
		's5_1': inst({fg: mopt['r5'].fg, anchor: ['end', 'bottom']}),
		's5_2': inst({fg: mopt['r5'].fg, anchor: ['start', 'middle']}),
		's6': station({fg: mopt['r6'].fg, anchor: ['start', 'middle']}),
		's6_1': station({fg: mopt['r6'].fg, anchor: ['end', 'middle']}),
		's6_2': inst({fg: mopt['r6'].fg, anchor: ['start', 'middle']}),
		's6_3': inst({fg: mopt['r6'].fg, anchor: ['end', 'bottom']}),
		's6_4': inst({fg: mopt['r6'].fg, anchor: ['start', 'top']}),
		's6_5': inst({fg: mopt['r6'].fg, anchor: ['end', 'middle']}),
		's6_6': inst({fg: mopt['r6'].fg, anchor: ['end', 'top']}),
		's6_7': inst({fg: mopt['r6'].fg, anchor: ['start', 'bottom']}),
		's7': station({fg: mopt['r7'].fg, anchor: ['end', 'middle']}),
		's7_1': inst({fg: mopt['r7'].fg, anchor: ['end', 'middle']}),
		's7_2': inst({fg: mopt['r7'].fg, anchor: ['start', 'bottom']}),
		's7_3': inst({fg: mopt['r7'].fg, anchor: ['start', 'top']}),
		's7_4': station({fg: mopt['r7'].fg, anchor: ['start', 'bottom']}),
		's7_5': inst_d({fg: mopt['r7'].fg}),
		's7_6': inst({fg: mopt['r7'].fg, anchor: ['start', 'middle']}),
		's7_7': station({fg: mopt['r7'].fg, anchor: ['center', 'bottom']}),
		's7_8': station({fg: mopt['r7'].fg, anchor: ['end', 'top']}),
		's8': station({fg: mopt['r8'].fg, anchor: ['start', 'middle']}),
		's8_1': inst({fg: mopt['r8'].fg}),
		's8_2': inst({fg: mopt['r8'].fg, anchor: ['start', 'top']}),
		's8_3': inst({fg: mopt['r8'].fg, anchor: ['start', 'top']}),
		's8_4': inst({fg: mopt['r8'].fg, anchor: ['end', 'top']}),
		's8_5': inst({fg: mopt['r8'].fg, anchor: ['end', 'bottom']}),
		's8_6': inst_d({fg: mopt['r8'].fg}),
		's9': station({fg: mopt['r9'].fg, anchor: ['start', 'middle']}),
		's9_1': inst({fg: mopt['r9'].fg, anchor: ['end', 'middle']}),
		's9_2': inst({fg: mopt['r9'].fg, anchor: ['start', 'middle']}),
		's9_3': inst({fg: mopt['r9'].fg, anchor: ['start', 'top']}),
		's9_4': station({fg: mopt['r9'].fg, anchor: ['end', 'middle']}),
		's9_5': inst({fg: mopt['r9'].fg, anchor: ['start', 'bottom']}),
		's9_6': inst({fg: mopt['r9'].fg, anchor: ['end', 'top']}),
		's10': station({fg: mopt['r10'].fg, anchor: ['end', 'middle']}),
		's10_1': station({fg: mopt['r10'].fg, anchor: ['start', 'middle']}),
		's10_2': inst({fg: mopt['r10'].fg, anchor: ['start', 'middle']}),
		's10_3': inst({fg: mopt['r10'].fg, anchor: ['end', 'top']}),
		's10_4': inst_d({fg: mopt['r10'].fg}),
		's11': station({fg: mopt['r11'].fg, anchor: ['center', 'bottom']}),
		's11_1': inst({fg: mopt['r11'].fg, anchor: ['start', 'top']}),
		's11_2': inst_d({fg: mopt['r11'].fg}),
		's12': station({fg: mopt['r12'].fg, anchor: ['center', 'bottom']}),
		's12_1': station({fg: mopt['r12'].fg, anchor: ['center', 'top']}),
		's12_2': station({fg: mopt['r12'].fg, anchor: ['start', 'top']}),
		's12_3': station({fg: mopt['r12'].fg, anchor: ['end', 'middle']}),
		's12_4': inst({fg: mopt['r12'].fg, anchor: ['center', 'bottom']}),
		's12_5': inst({fg: mopt['r12'].fg, anchor: ['start', 'top']}),
		'sTPK': station({fg: mopt['rTPK'].fg, anchor: ['start', 'top']}),
		'sTPK_1': station({fg: mopt['rTPK'].fg, anchor: ['start', 'middle']}),
		'sTPK_2': station({fg: mopt['rTPK'].fg, anchor: ['end', 'middle']}),
		'sTPK_3': inst({fg: mopt['rTPK'].fg, anchor: ['start', 'middle']}),
		'sTPK_4': inst({fg: mopt['rTPK'].fg, anchor: ['start', 'bottom']}),
		'sTPK_5': inst_d({fg: mopt['rTPK'].fg}),
		'sTPK_6': station({fg: mopt['rTPK'].fg, anchor: ['center', 'bottom']}),
		'sTPK_7': station({fg: mopt['rTPK'].fg, anchor: ['start', 'middle']}),
		'sTPK_8': station({fg: mopt['rTPK'].fg, anchor: ['end', 'bottom']}),
		'sTPK_9': inst({fg: mopt['rTPK'].fg, anchor: ['end', 'middle']}),
		'sTPK_10': station({fg: mopt['rTPK'].fg, anchor: ['start', 'bottom']}),
		'sTPK_11': inst({fg: mopt['rTPK'].fg, anchor: ['start', 'top']}),
		'sTPK_12': inst({fg: mopt['rTPK'].fg, anchor: ['end', 'top']}),
		'sTPK_13': inst({fg: mopt['rTPK'].fg, anchor: ['center', 'top']}),
		'sTPK_14': inst({fg: mopt['rTPK'].fg, anchor: ['center', 'bottom']}),
		'sKOZH': station({fg: mopt['rKOZH'].fg, anchor: ['start', 'middle']}),
		'sKOZH_1': station({fg: mopt['rKOZH'].fg, anchor: ['end', 'middle']}),
		'sKOZH_2': inst({fg: mopt['rKOZH'].fg, anchor: ['start', 'middle']}),
		'sKOZH_3': inst_d({fg: mopt['rKOZH'].fg, anchor: ['start', 'middle']}),
		'sMono': inst({fg: mopt['monorail'].fg, size: 3, anchor: ['start', 'top']}),
		'sMono_1': inst({fg: mopt['monorail'].fg, size: 3, anchor: ['start', 'middle']}),
		'sMCK': mck_station({anchor: ['start', 'middle']}),
		'sMCK_1': mck_station({anchor: ['start', 'top']}),
		'sMCK_2': mck_station({anchor: ['end', 'middle']}),
		'sMCK_3': mck_station({anchor: ['center', 'bottom']}),
		'sMCK_4': mck_station({anchor: ['start', 'bottom']})
	});
	// lines
	for (var i = 0; i < MLINES.length; i++) {
		var ftype = MLINES[i][0],
			abbr = MLINES[i][1],
			coords = MLINES[i][2];
		var pts = dw.interpolateCoords(coords, true),
			mpts = [], n = 0;
		for (var j = 0; j < pts.length; j++) {
			if (pts[j][2] == 'Q') { // bezier check
				n++;
				if (j > 0 && n == 1) mpts.push('L');
				else if (n == 2) mpts.push('Q');
				else if (n > 2) n = 0;
			} else if (j > 0) {
				mpts.push('L');
			}
			mpts.push(pts[j][0], pts[j][1]);
		}
		var path = ('M ' + mpts).replace(/,/g, ' ');
		var o = dw.append('path', {
			class: [i, ftype, abbr].join(),
			fill: 'transparent',
			stroke: mopt[ftype].fg,
			'stroke-dasharray': mopt[ftype].dash,
			'stroke-linejoin': mopt[ftype].join,
			'stroke-linecap': mopt[ftype].cap,
			'stroke-width': mopt[ftype].width,
			d: path
		});
	}
	;
	// stations
	for (var i = 0; i < MSTATIONS.length; i++) {
		var ftype = MSTATIONS[i][0],
			abbr = MSTATIONS[i][1],
			coords = MSTATIONS[i][2][0],
			label = MSTATIONS[i][3];
		var pts = dw.toPoints(coords, true),
			a, dx = 10, dy = 0;
		var station = dw.append('circle', {
			class: label,
			cx: pts[0], cy: pts[1], r: mopt[ftype].size,
			fill: mopt[ftype].bg,
			stroke: mopt[ftype].fg
		});
		if (!label) continue;
		if (a = mopt[ftype].anchor) {
			if (a[0] == 'start') dx = 10;
			else if (a[0] == 'center') dx = -40;
			else if (a[0] == 'end') dx = -10;
			if (a[1] == 'top') dy = 10;
			else if (a[1] == 'middle') dy = 4;
			else if (a[1] == 'bottom') dy = -10;
		}
		;
		var text = dw.append('text', {
			x: pts[0] + dx, y: pts[1] + dy,
			fill: mopt[ftype].labelcolor || '',
			'font-family': 'sans-serif', 'font-size': '0px',
			'text-anchor': a ? a[0] : ''
		});
		text.appendChild(document.createTextNode(station.getAttribute('class')));
		dw.extend(station, {
			onmousemove: function (ev) {
				var scale = 3;
				var ratio = scale / (scale - 1);
				var cx = this.getAttribute('cx') / ratio,
					cy = this.getAttribute('cy') / ratio;
				dw.doMap(ev, {
					display: 'block',
					transform: 'scale(' + scale + ') translate(' + -cx + ',' + -cy + ')'
				});
			}
		});
	}
	;
	// labels (MLABEL)
	for (var i = 0; i < MLABEL.length; i++) {
		var ftype = MLABEL[i][0],
			label = MLABEL[i][3],
			coords = MLABEL[i][4];
		var pts = dw.toPoints(coords, true);
		if (a = mopt[ftype].anchor) {
			if (a[0] == 'start') dx = 10;
			else if (a[0] == 'center') dx = -40;
			else if (a[0] == 'end') dx = -10;
			if (a[1] == 'top') dy = 10;
			else if (a[1] == 'middle') dy = 4;
			else if (a[1] == 'bottom') dy = -10;
		}
		;
		var text = dw.append('text', {
			x: pts[0] + dx, y: pts[1] + dy,
			fill: mopt[ftype].labelcolor || '',
			'font-family': 'sans-serif', 'font-size': '9px',
			'text-anchor': a ? a[0] : ''
		});
		if ('rotate' in mopt[ftype]) {
			dw.attr(text, {
				transform: 'rotate(' + mopt[ftype].rotate + ',' + pts[0] + ',' + pts[1] + ')'
			});
		}
		text.appendChild(document.createTextNode(label));
	}
	;
};

dw = new dbCartaSvg({
	id: 'mcont',
	width: '350',
	height: document.getElementById('mcont').offsetHeight,
	sbarpos: 'left',
	bg: 'white'
});
// events
// dw.extend(dw.root, {
// 	onmousemove: function (ev) {
// 		dw.mousemove(ev);
// 		infobox(ev);
// 	}
// });
allmaps.push(draw);*/

/* main slider */
$('.main-banner__slider').slick({
    dots: true,
    arrows: true,
    responsive: [
        {
            breakpoint: 769,
            settings: {
                arrows: false
            }
        }
    ]
});

/* map info slider */
$('.map-info--slider').slick({
    dots: false,
    arrows: true,
    responsive: [
        {
            breakpoint: 990,
            settings: {
                slidesToShow: 1,
                slidesToScroll: 1,
                swipe: false
            }
        }
    ]
});

/* news slider */
$('.news-slider').slick({
    dots: false,
    arrows: true,
    fade: true
});
$('.news-list-slider').slick({
	dots: true,
	arrows: true,
	adaptiveHeight: true
});
$('.discounts-for').slick({
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    infinite: false,
    fade: false,
    asNavFor: '.discounts-nav'
});
$('.discounts-nav').slick({
    slidesToShow: 4,
    slidesToScroll: 1,
    asNavFor: '.discounts-for',
    arrows: true,
    infinite: false,
    focusOnSelect: true,
    responsive: [
        {
            breakpoint: 768,
            settings: {
                slidesToShow: 2,
                slidesToScroll: 1,
                arrows: false
            }
        }, {
            breakpoint: 770,
            settings: {
                slidesToShow: 4,
                slidesToScroll: 1,
                arrows: false
            }
        }
    ]
});
/* */
if ($(".lightbox").length > 0) {
    lightbox(".lightbox", {
        captions: false,
        nav: "auto",
        navText: ["<i class='prev'></i>", "<i class='next'></i>"],
        close: true,
        closeText: "<i class='close'></i>",
        counter: false,
        keyboard: true,
        zoom: false,
        docClose: true,
        swipeClose: true,
        scroll: false
    });
}
/* textarea resize auto height */
(function ($) {
    /**
     * Auto-growing textareas; technique ripped from Facebook
     *
     *
     * http://github.com/jaz303/jquery-grab-bag/tree/master/javascripts/jquery.autogrow-textarea.js
     */
    $.fn.autogrow = function (options) {
        return this.filter('textarea').each(function () {
            var self = this;
            var $self = $(self);
            var minHeight = $self.height();
            var noFlickerPad = $self.hasClass('autogrow-short') ? 0 : parseInt($self.css('lineHeight')) || 0;
            var settings = $.extend({
                preGrowCallback: null,
                postGrowCallback: null
            }, options);

            var shadow = $('<div></div>').css({
                position: 'absolute',
                top: -10000,
                left: -10000,
                width: $self.width(),
                fontSize: $self.css('fontSize'),
                fontFamily: $self.css('fontFamily'),
                fontWeight: $self.css('fontWeight'),
                lineHeight: $self.css('lineHeight'),
                resize: 'none',
                'word-wrap': 'break-word'
            }).appendTo(document.body);

            var update = function (event) {
                var times = function (string, number) {
                    for (var i = 0, r = ''; i < number; i++) r += string;
                    return r;
                };

                var val = self.value.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/\n$/, '<br/>&#xa0;')
                    .replace(/\n/g, '<br/>')
                    .replace(/ {2,}/g, function (space) {
                        return times('&#xa0;', space.length - 1) + ' '
                    });

                // Did enter get pressed?  Resize in this keydown event so that the flicker doesn't occur.
                if (event && event.data && event.data.event === 'keydown' && event.keyCode === 13) {
                    val += '<br />';
                }

                shadow.css('width', $self.width());
                shadow.html(val + (noFlickerPad === 0 ? '...' : '')); // Append '...' to resize pre-emptively.

                var newHeight = Math.max(shadow.height() + noFlickerPad, minHeight);
                if (settings.preGrowCallback != null) {
                    newHeight = settings.preGrowCallback($self, shadow, newHeight, minHeight);
                }

                $self.height(newHeight);

                if (settings.postGrowCallback != null) {
                    settings.postGrowCallback($self);
                }
            }

            $self.change(update).keyup(update).keydown({event: 'keydown'}, update);
            $(window).resize(update);

            update();
        });
    };
})(jQuery);

$(function () {
    $('textarea').autogrow();
});